diff --git a/src/services/anthropicGeminiBridgeService.js b/src/services/anthropicGeminiBridgeService.js
index 31532406..83052c88 100644
--- a/src/services/anthropicGeminiBridgeService.js
+++ b/src/services/anthropicGeminiBridgeService.js
@@ -41,10 +41,11 @@ const signatureCache = require('../utils/signatureCache')
 const apiKeyService = require('./apiKeyService')
 const { updateRateLimitCounters } = require('../utils/rateLimitHelper')
 const { parseSSELine } = require('../utils/sseParser')
 const { sanitizeUpstreamError } = require('../utils/errorSanitizer')
 const { cleanJsonSchemaForGemini } = require('../utils/geminiSchemaCleaner')
+const { parseGoogleErrorReason, parseGoogleRetryDelayMs } = require('../utils/googleErrorParser')
 const {
   dumpAnthropicNonStreamResponse,
   dumpAnthropicStreamSummary
 } = require('../utils/anthropicResponseDump')
 const {
@@ -79,10 +80,16 @@ const ANTIGRAVITY_TOOL_FOLLOW_THROUGH_PROMPT =
   'When a step requires calling a tool, call the tool immediately in the same turn. Do not stop after announcing the step. Updating todos alone (e.g., TodoWrite) is not enough; you must actually invoke the target MCP tool (browser_*, etc.) before ending the turn.'
 // å·¥å…·æŠ¥é”™æ—¶æ³¨å…¥çš„ system promptï¼Œæç¤ºæ¨¡å‹ä¸è¦ä¸­æ–­
 const TOOL_ERROR_CONTINUE_PROMPT =
   'Tool calls may fail (e.g., missing prerequisites). When a tool result indicates an error, do not stop: briefly explain the cause and continue with an alternative approach or the remaining steps.'
 
+// Antigravity 429 reason åˆ†æµï¼šå‚è€ƒ Antigravity-Manager
+const ANTIGRAVITY_DEFAULT_RATE_LIMIT_SECONDS = 30
+const ANTIGRAVITY_QUOTA_LOCKOUT_SECONDS = [60, 300, 1800, 7200] // 60sâ†’5mâ†’30mâ†’2h
+const ANTIGRAVITY_QUOTA_STRIKE_TTL_MS = 6 * 60 * 60 * 1000
+const antigravityQuotaStrikesByAccountId = new Map()
+
 // ============================================================================
 // è¾…åŠ©å‡½æ•°ï¼šåŸºç¡€å·¥å…·
 // ============================================================================
 
 /**
@@ -227,23 +234,782 @@ const MAX_ANTIGRAVITY_TOOL_RESULT_CHARS = 200000
 // è¾…åŠ©å‡½æ•°ï¼šAntigravity ä½“ç§¯å‹ç¼©
 // è¿™äº›å‡½æ•°ç”¨äºå‹ç¼©å·¥å…·æè¿°ã€schema ç­‰ï¼Œé¿å… prompt è¶…è¿‡ Antigravity çš„ä¸Šé™
 // ============================================================================
 
 /**
- * æˆªæ–­æ–‡æœ¬å¹¶æ·»åŠ æˆªæ–­æç¤ºï¼ˆå¸¦æ¢è¡Œï¼‰
- * @param {string} text - åŸå§‹æ–‡æœ¬
- * @param {number} maxChars - æœ€å¤§å­—ç¬¦æ•°
- * @returns {string} æˆªæ–­åçš„æ–‡æœ¬
+ * æ£€æŸ¥ä¸¤ä¸ªæ¨¡å‹æ˜¯å¦å…¼å®¹ï¼ˆåŒä¸€æ¨¡å‹å®¶æ—ï¼‰
+ * ç”¨äºé˜²æ­¢è·¨æ¨¡å‹ç­¾åé”™è¯¯
+ * å‚è€ƒ: Antigravity-Manager request.rs is_model_compatible
+ * @param {string} cachedFamily - ç¼“å­˜çš„æ¨¡å‹å®¶æ—
+ * @param {string} targetModel - ç›®æ ‡æ¨¡å‹åç§°
+ * @returns {boolean} æ˜¯å¦å…¼å®¹
+ */
+function isModelCompatible(cachedFamily, targetModel) {
+  if (!cachedFamily || !targetModel) {
+    return true // æ— æ³•åˆ¤æ–­æ—¶é»˜è®¤å…¼å®¹
+  }
+
+  const c = cachedFamily.toLowerCase()
+  const t = targetModel.toLowerCase()
+
+  if (c === t) {
+    return true
+  }
+
+  // æ£€æŸ¥ç‰¹å®šæ¨¡å‹å®¶æ—
+  if (c.includes('gemini-1.5') && t.includes('gemini-1.5')) {
+    return true
+  }
+  if (c.includes('gemini-2.0') && t.includes('gemini-2.0')) {
+    return true
+  }
+  if (c.includes('gemini-2.5') && t.includes('gemini-2.5')) {
+    return true
+  }
+  if (c.includes('claude-3-5') && t.includes('claude-3-5')) {
+    return true
+  }
+  if (c.includes('claude-3-7') && t.includes('claude-3-7')) {
+    return true
+  }
+  if (c.includes('claude-sonnet-4') && t.includes('claude-sonnet-4')) {
+    return true
+  }
+  if (c.includes('claude-opus-4') && t.includes('claude-opus-4')) {
+    return true
+  }
+
+  // ä¸¥æ ¼æ¨¡å¼ï¼šä¸åŒå®¶æ—ä¸å…¼å®¹
+  return false
+}
+
+/**
+ * ä»æ¨¡å‹åç§°æå–æ¨¡å‹å®¶æ—æ ‡è¯†
+ * @param {string} modelName - æ¨¡å‹åç§°
+ * @returns {string} æ¨¡å‹å®¶æ—æ ‡è¯†
  */
-function truncateText(text, maxChars) {
+function extractModelFamily(modelName) {
+  if (!modelName) {
+    return ''
+  }
+  const name = modelName.toLowerCase()
+
+  // Gemini æ¨¡å‹
+  if (name.includes('gemini-2.5')) {
+    return 'gemini-2.5'
+  }
+  if (name.includes('gemini-2.0')) {
+    return 'gemini-2.0'
+  }
+  if (name.includes('gemini-1.5')) {
+    return 'gemini-1.5'
+  }
+
+  // Claude æ¨¡å‹
+  if (name.includes('claude-opus-4')) {
+    return 'claude-opus-4'
+  }
+  if (name.includes('claude-sonnet-4')) {
+    return 'claude-sonnet-4'
+  }
+  if (name.includes('claude-3-7')) {
+    return 'claude-3-7'
+  }
+  if (name.includes('claude-3-5')) {
+    return 'claude-3-5'
+  }
+
+  return name
+}
+
+// ============================================================================
+// ContextManager: ä¸Šä¸‹æ–‡ç®¡ç†å™¨
+// å‚è€ƒ: Antigravity-Manager context_manager.rs
+// ============================================================================
+
+/**
+ * å‡€åŒ–ç­–ç•¥æšä¸¾
+ * - None: ä¸æ¸…ç†
+ * - Soft: ä¿ç•™æœ€è¿‘ 2 è½®ï¼ˆ4 æ¡æ¶ˆæ¯ï¼‰çš„ thinking blocks
+ * - Aggressive: ç§»é™¤æ‰€æœ‰å†å² thinking blocks
+ */
+const PurificationStrategy = {
+  None: 'none',
+  Soft: 'soft',
+  Aggressive: 'aggressive'
+}
+
+/**
+ * ä¼°ç®—æ¶ˆæ¯çš„ Token ä½¿ç”¨é‡
+ * è½»é‡çº§ä¼°ç®—ï¼šçº¦ 3.5 å­—ç¬¦ = 1 token
+ * å‚è€ƒ: Antigravity-Manager ContextManager::estimate_token_usage
+ * @param {Object} body - Anthropic è¯·æ±‚ä½“
+ * @returns {number} ä¼°ç®—çš„ token æ•°é‡
+ */
+function estimateTokenUsage(body) {
+  let total = 0
+
+  const estimateFromStr = (s) => {
+    if (!s || typeof s !== 'string') {
+      return 0
+    }
+    return Math.ceil(s.length / 3.5)
+  }
+
+  // System prompt
+  if (body.system) {
+    if (typeof body.system === 'string') {
+      total += estimateFromStr(body.system)
+    } else if (Array.isArray(body.system)) {
+      for (const block of body.system) {
+        if (block?.text) {
+          total += estimateFromStr(block.text)
+        }
+      }
+    }
+  }
+
+  // Messages
+  for (const msg of body.messages || []) {
+    total += 4 // message overhead
+
+    const content = msg?.content
+    if (typeof content === 'string') {
+      total += estimateFromStr(content)
+    } else if (Array.isArray(content)) {
+      for (const block of content) {
+        if (!block) {
+          continue
+        }
+
+        if (block.type === 'text') {
+          total += estimateFromStr(block.text)
+        } else if (block.type === 'thinking') {
+          total += estimateFromStr(block.thinking)
+          total += 100 // signature overhead
+        } else if (block.type === 'redacted_thinking') {
+          total += estimateFromStr(block.data)
+        } else if (block.type === 'tool_use') {
+          total += 20 // function call overhead
+          total += estimateFromStr(block.name)
+          if (block.input) {
+            try {
+              total += estimateFromStr(JSON.stringify(block.input))
+            } catch (_) {
+              // ignore
+            }
+          }
+        } else if (block.type === 'tool_result') {
+          total += 10 // result overhead
+          if (typeof block.content === 'string') {
+            total += estimateFromStr(block.content)
+          } else if (Array.isArray(block.content)) {
+            for (const item of block.content) {
+              if (item?.text) {
+                total += estimateFromStr(item.text)
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  // Tools definition overhead
+  if (Array.isArray(body.tools)) {
+    for (const tool of body.tools) {
+      try {
+        total += estimateFromStr(JSON.stringify(tool))
+      } catch (_) {
+        // ignore
+      }
+    }
+  }
+
+  // Thinking budget overhead
+  if (body.thinking?.budget_tokens) {
+    total += Number(body.thinking.budget_tokens) || 0
+  }
+
+  return total
+}
+
+/**
+ * æ ¹æ®ä¸Šä¸‹æ–‡ä½¿ç”¨ç‡ç¡®å®šå‡€åŒ–ç­–ç•¥
+ * - > 90%: Aggressiveï¼ˆæ¿€è¿›å‰¥ç¦»æ‰€æœ‰å†å² thinkingï¼‰
+ * - > 60%: Softï¼ˆä¿ç•™æœ€è¿‘ 2 è½® thinkingï¼‰
+ * - < 60%: Noneï¼ˆä¸å¤„ç†ï¼‰
+ * @param {number} usageRatio - ä½¿ç”¨ç‡ (0-1)
+ * @returns {string} å‡€åŒ–ç­–ç•¥
+ */
+function determinePurificationStrategy(usageRatio) {
+  if (usageRatio > 0.9) {
+    return PurificationStrategy.Aggressive
+  }
+  if (usageRatio > 0.6) {
+    return PurificationStrategy.Soft
+  }
+  return PurificationStrategy.None
+}
+
+/**
+ * å‡€åŒ–å†å²æ¶ˆæ¯ä¸­çš„ thinking blocks
+ * å‚è€ƒ: Antigravity-Manager ContextManager::purify_history
+ * @param {Array} messages - æ¶ˆæ¯åˆ—è¡¨ï¼ˆä¼šè¢«åŸåœ°ä¿®æ”¹ï¼‰
+ * @param {string} strategy - å‡€åŒ–ç­–ç•¥
+ * @returns {boolean} æ˜¯å¦è¿›è¡Œäº†ä¿®æ”¹
+ */
+function purifyHistoryThinking(messages, strategy) {
+  if (strategy === PurificationStrategy.None) {
+    return false
+  }
+
+  if (!Array.isArray(messages) || messages.length === 0) {
+    return false
+  }
+
+  let modified = false
+  const totalMsgs = messages.length
+
+  // Soft æ¨¡å¼ä¿æŠ¤æœ€å 4 æ¡æ¶ˆæ¯ï¼ˆçº¦ 2 è½®å¯¹è¯ï¼‰
+  const protectedCount = strategy === PurificationStrategy.Soft ? 4 : 0
+  const startProtectionIdx = Math.max(0, totalMsgs - protectedCount)
+
+  for (let i = 0; i < messages.length; i++) {
+    const msg = messages[i]
+    const isProtected = i >= startProtectionIdx
+
+    // åªå¤„ç† assistant æ¶ˆæ¯
+    if (msg?.role !== 'assistant' || isProtected) {
+      continue
+    }
+
+    if (!Array.isArray(msg.content)) {
+      continue
+    }
+
+    const originalLen = msg.content.length
+    // è¿‡æ»¤æ‰ thinking å’Œ redacted_thinking blocks
+    msg.content = msg.content.filter(
+      (block) => block?.type !== 'thinking' && block?.type !== 'redacted_thinking'
+    )
+
+    if (msg.content.length !== originalLen) {
+      modified = true
+
+      // å¦‚æœæ¶ˆæ¯å˜ç©ºï¼Œæ·»åŠ å ä½ç¬¦ä¿æŒå¯¹è¯ç»“æ„
+      if (msg.content.length === 0) {
+        msg.content.push({ type: 'text', text: '...' })
+        logger.debug('[ContextManager] Replaced empty assistant message with placeholder')
+      }
+    }
+  }
+
+  if (modified) {
+    logger.info(
+      `[ContextManager] Purified history with strategy: ${strategy} (Protected last ${protectedCount} msgs)`
+    )
+  }
+
+  return modified
+}
+
+// ============================================================================
+// Thinking Utils: å·¥å…·å¾ªç¯æ£€æµ‹ä¸ä¿®å¤
+// å‚è€ƒ: Antigravity-Manager thinking_utils.rs
+// ============================================================================
+
+const MIN_SIGNATURE_LENGTH = 50
+
+/**
+ * åˆ†æä¼šè¯çŠ¶æ€ï¼Œæ£€æµ‹å·¥å…·å¾ªç¯å’Œä¸­æ–­
+ * å‚è€ƒ: Antigravity-Manager analyze_conversation_state
+ * @param {Array} messages - æ¶ˆæ¯åˆ—è¡¨
+ * @returns {Object} { inToolLoop, interruptedTool, lastAssistantIdx }
+ */
+function analyzeConversationState(messages) {
+  const state = {
+    inToolLoop: false,
+    interruptedTool: false,
+    lastAssistantIdx: null
+  }
+
+  if (!Array.isArray(messages) || messages.length === 0) {
+    return state
+  }
+
+  // æ‰¾åˆ°æœ€åä¸€æ¡ assistant æ¶ˆæ¯
+  for (let i = messages.length - 1; i >= 0; i--) {
+    if (messages[i]?.role === 'assistant') {
+      state.lastAssistantIdx = i
+      break
+    }
+  }
+
+  if (state.lastAssistantIdx === null) {
+    return state
+  }
+
+  // æ£€æŸ¥ assistant æ¶ˆæ¯æ˜¯å¦æœ‰ tool_use
+  const assistantMsg = messages[state.lastAssistantIdx]
+  const assistantContent = Array.isArray(assistantMsg?.content) ? assistantMsg.content : []
+  const hasToolUse = assistantContent.some((b) => b?.type === 'tool_use')
+
+  if (!hasToolUse) {
+    return state
+  }
+
+  // æ£€æŸ¥æœ€åä¸€æ¡æ¶ˆæ¯
+  const lastMsg = messages[messages.length - 1]
+  if (lastMsg?.role !== 'user') {
+    return state
+  }
+
+  const lastContent = lastMsg?.content
+  if (Array.isArray(lastContent)) {
+    // Case 1: æœ€åæ¶ˆæ¯æ˜¯ ToolResult -> æ´»è·ƒçš„å·¥å…·å¾ªç¯
+    if (lastContent.some((b) => b?.type === 'tool_result')) {
+      state.inToolLoop = true
+      logger.debug('[Thinking-Recovery] Active tool loop detected (last msg is ToolResult).')
+    } else {
+      // Case 2: æœ€åæ¶ˆæ¯æ˜¯æ–‡æœ¬ -> ä¸­æ–­çš„å·¥å…·è°ƒç”¨
+      state.interruptedTool = true
+      logger.debug('[Thinking-Recovery] Interrupted tool detected (last msg is Text user).')
+    }
+  } else if (typeof lastContent === 'string') {
+    // Case 2: å­—ç¬¦ä¸²å†…å®¹ -> ä¸­æ–­çš„å·¥å…·è°ƒç”¨
+    state.interruptedTool = true
+    logger.debug('[Thinking-Recovery] Interrupted tool detected (last msg is String user).')
+  }
+
+  return state
+}
+
+/**
+ * ä¿®å¤æ–­è£‚çš„å·¥å…·å¾ªç¯
+ * å½“ assistant æ¶ˆæ¯æœ‰ tool_use ä½†ç¼ºå°‘æœ‰æ•ˆçš„ thinking block æ—¶ï¼Œ
+ * æ³¨å…¥åˆæˆæ¶ˆæ¯æ¥å…³é—­å¾ªç¯ï¼Œé¿å… "Assistant message must start with thinking" é”™è¯¯
+ * å‚è€ƒ: Antigravity-Manager close_tool_loop_for_thinking
+ * @param {Array} messages - æ¶ˆæ¯åˆ—è¡¨ï¼ˆä¼šè¢«åŸåœ°ä¿®æ”¹ï¼‰
+ * @returns {boolean} æ˜¯å¦è¿›è¡Œäº†ä¿®æ”¹
+ */
+function closeToolLoopForThinking(messages) {
+  const state = analyzeConversationState(messages)
+
+  if (!state.inToolLoop && !state.interruptedTool) {
+    return false
+  }
+
+  // æ£€æŸ¥æœ€åä¸€æ¡ assistant æ¶ˆæ¯æ˜¯å¦æœ‰æœ‰æ•ˆçš„ thinking block
+  let hasValidThinking = false
+  if (state.lastAssistantIdx !== null) {
+    const assistantMsg = messages[state.lastAssistantIdx]
+    const content = Array.isArray(assistantMsg?.content) ? assistantMsg.content : []
+
+    for (const block of content) {
+      if (block?.type === 'thinking') {
+        const thinking = block.thinking || ''
+        const signature = block.signature || ''
+        if (thinking && signature.length >= MIN_SIGNATURE_LENGTH) {
+          hasValidThinking = true
+          break
+        }
+      }
+    }
+  }
+
+  if (hasValidThinking) {
+    return false
+  }
+
+  if (state.inToolLoop) {
+    logger.info(
+      '[Thinking-Recovery] Broken tool loop (ToolResult without preceding Thinking). Recovery triggered.'
+    )
+
+    // æ³¨å…¥ç¡®è®¤æ¶ˆæ¯æ¥"å…³é—­"å†å²è½®æ¬¡
+    messages.push({
+      role: 'assistant',
+      content: [
+        { type: 'text', text: '[System: Tool execution completed. Proceeding to final response.]' }
+      ]
+    })
+    messages.push({
+      role: 'user',
+      content: [
+        { type: 'text', text: 'Please provide the final result based on the tool output above.' }
+      ]
+    })
+    return true
+  }
+
+  if (state.interruptedTool) {
+    logger.info('[Thinking-Recovery] Interrupted tool call detected. Injecting synthetic closure.')
+
+    // åœ¨ assistant çš„ tool_use åæ’å…¥é—­åŒ…æ¶ˆæ¯
+    if (state.lastAssistantIdx !== null) {
+      messages.splice(state.lastAssistantIdx + 1, 0, {
+        role: 'assistant',
+        content: [{ type: 'text', text: '[Tool call was interrupted by user.]' }]
+      })
+    }
+    return true
+  }
+
+  return false
+}
+
+// ============================================================================
+// Streaming å‚æ•°é‡æ˜ å°„: ä¿®å¤ Gemini è¿”å›çš„å·¥å…·è°ƒç”¨å‚æ•°
+// å‚è€ƒ: Antigravity-Manager streaming.rs remap_function_call_args
+// ============================================================================
+
+/**
+ * é‡æ˜ å°„å·¥å…·è°ƒç”¨å‚æ•°
+ * Gemini æœ‰æ—¶ä¼šä½¿ç”¨ä¸ Claude Code æœŸæœ›ä¸åŒçš„å‚æ•°å
+ * æ­¤å‡½æ•°ä¿®å¤è¿™äº›ä¸ä¸€è‡´ï¼Œé¿å…å·¥å…·è°ƒç”¨å¤±è´¥
+ *
+ * å¸¸è§æ˜ å°„ï¼š
+ * - Grep/Glob: description â†’ pattern, query â†’ pattern, paths â†’ path
+ * - Read: path â†’ file_path
+ * - LS: é»˜è®¤ path = "."
+ * - EnterPlanMode: æ¸…é™¤æ‰€æœ‰å‚æ•°ï¼ˆç¦æ­¢æºå¸¦ä»»ä½•å‚æ•°ï¼‰
+ *
+ * @param {string} name - å·¥å…·åç§°
+ * @param {Object} args - å·¥å…·å‚æ•°ï¼ˆä¼šè¢«åŸåœ°ä¿®æ”¹ï¼‰
+ */
+function remapFunctionCallArgs(name, args) {
+  if (!args || typeof args !== 'object') {
+    return
+  }
+
+  const nameLower = (name || '').toLowerCase()
+
+  // [IMPORTANT] Claude Code CLI çš„ EnterPlanMode å·¥å…·ç¦æ­¢æºå¸¦ä»»ä½•å‚æ•°
+  // ä»£ç†å±‚æ³¨å…¥çš„ reason å‚æ•°ä¼šå¯¼è‡´ InputValidationError
+  if (nameLower === 'enterplanmode') {
+    for (const key of Object.keys(args)) {
+      delete args[key]
+    }
+    return
+  }
+
+  // Grep, Search, Glob å·¥å…·å‚æ•°ä¿®å¤
+  if (
+    nameLower === 'grep' ||
+    nameLower === 'search' ||
+    nameLower === 'glob' ||
+    nameLower === 'search_code_definitions' ||
+    nameLower === 'search_code_snippets'
+  ) {
+    // Gemini å¹»è§‰ï¼šå°†å‚æ•°æè¿°æ˜ å°„åˆ° "description" å­—æ®µ
+    if (args.description && !args.pattern) {
+      args.pattern = args.description
+      delete args.description
+      logger.debug(`[Streaming] Remapped ${name}: description â†’ pattern`)
+    }
+
+    // Gemini ä½¿ç”¨ "query"ï¼ŒClaude Code æœŸæœ› "pattern"
+    if (args.query && !args.pattern) {
+      args.pattern = args.query
+      delete args.query
+      logger.debug(`[Streaming] Remapped ${name}: query â†’ pattern`)
+    }
+
+    // [CRITICAL FIX] Claude Code ä½¿ç”¨ "path" (string)ï¼Œä¸æ˜¯ "paths" (array)!
+    if (!args.path) {
+      if (args.paths) {
+        const { paths } = args
+        let pathStr = '.'
+        if (Array.isArray(paths) && paths.length > 0) {
+          pathStr = typeof paths[0] === 'string' ? paths[0] : '.'
+        } else if (typeof paths === 'string') {
+          pathStr = paths
+        }
+        args.path = pathStr
+        delete args.paths
+        logger.debug(`[Streaming] Remapped ${name}: paths â†’ path("${pathStr}")`)
+      } else {
+        // é»˜è®¤ä½¿ç”¨å½“å‰ç›®å½•
+        args.path = '.'
+        logger.debug(`[Streaming] Added default path: "."`)
+      }
+    }
+    return
+  }
+
+  // Read å·¥å…·å‚æ•°ä¿®å¤
+  if (nameLower === 'read') {
+    // Gemini å¯èƒ½ä½¿ç”¨ "path"ï¼ŒClaude Code æœŸæœ› "file_path"
+    if (args.path && !args.file_path) {
+      args.file_path = args.path
+      delete args.path
+      logger.debug('[Streaming] Remapped Read: path â†’ file_path')
+    }
+    return
+  }
+
+  // LS å·¥å…·å‚æ•°ä¿®å¤
+  if (nameLower === 'ls') {
+    // ç¡®ä¿ "path" å‚æ•°å­˜åœ¨
+    if (!args.path) {
+      args.path = '.'
+      logger.debug('[Streaming] Remapped LS: default path â†’ "."')
+    }
+    return
+  }
+
+  // [é€šç”¨ä¿®å¤] å¦‚æœå·¥å…·æœ‰ "paths" (åªæœ‰ä¸€ä¸ªå…ƒç´ çš„æ•°ç»„) ä½†æ²¡æœ‰ "path"ï¼Œè½¬æ¢å®ƒ
+  if (!args.path && args.paths) {
+    const { paths } = args
+    if (Array.isArray(paths) && paths.length === 1 && typeof paths[0] === 'string') {
+      args.path = paths[0]
+      delete args.paths
+      logger.debug(`[Streaming] Generic fix for tool '${name}': paths[0] â†’ path("${args.path}")`)
+    }
+  }
+}
+
+// ============================================================================
+// Request å¤„ç†å¢å¼º: ä¸‰é˜¶æ®µåˆ†åŒºæ’åº + è¿ç»­æ¶ˆæ¯åˆå¹¶
+// å‚è€ƒ: Antigravity-Manager FIX #709, FIX #813
+// ============================================================================
+
+/**
+ * å¯¹ assistant æ¶ˆæ¯å†…å®¹è¿›è¡Œä¸‰é˜¶æ®µåˆ†åŒºæ’åº
+ * ç¡®ä¿ thinking blocks å§‹ç»ˆåœ¨æœ€å‰é¢ï¼ˆç¬¦åˆ Anthropic/Gemini åè®®è¦æ±‚ï¼‰
+ * å‚è€ƒ: Antigravity-Manager FIX #709 sort_thinking_blocks_first
+ * @param {Array} messages - æ¶ˆæ¯åˆ—è¡¨ï¼ˆä¼šè¢«åŸåœ°ä¿®æ”¹ï¼‰
+ * @returns {boolean} æ˜¯å¦è¿›è¡Œäº†ä¿®æ”¹
+ */
+function sortThinkingBlocksFirst(messages) {
+  if (!Array.isArray(messages)) {
+    return false
+  }
+
+  let modified = false
+
+  for (const msg of messages) {
+    if (msg?.role !== 'assistant') {
+      continue
+    }
+
+    if (!Array.isArray(msg.content) || msg.content.length <= 1) {
+      continue
+    }
+
+    const blocks = msg.content
+    const thinkingBlocks = []
+    const textBlocks = []
+    const toolBlocks = []
+    const otherBlocks = []
+
+    let sawNonThinking = false
+    let needsReorder = false
+
+    // æ£€æµ‹æ˜¯å¦éœ€è¦é‡æ’åº
+    for (const block of blocks) {
+      if (!block) {
+        continue
+      }
+
+      if (block.type === 'thinking' || block.type === 'redacted_thinking') {
+        if (sawNonThinking) {
+          needsReorder = true
+        }
+      } else if (block.type === 'text' || block.type === 'tool_use') {
+        sawNonThinking = true
+      } else {
+        sawNonThinking = true
+      }
+    }
+
+    if (!needsReorder && blocks.length <= 1) {
+      continue
+    }
+
+    // æ‰§è¡Œä¸‰é˜¶æ®µåˆ†åŒº
+    for (const block of blocks) {
+      if (!block) {
+        continue
+      }
+
+      if (block.type === 'thinking' || block.type === 'redacted_thinking') {
+        thinkingBlocks.push(block)
+      } else if (block.type === 'text') {
+        // è¿‡æ»¤ç©ºæ–‡æœ¬
+        const text = block.text?.trim()
+        if (text && text !== '(no content)') {
+          textBlocks.push(block)
+        }
+      } else if (block.type === 'tool_use') {
+        toolBlocks.push(block)
+      } else {
+        otherBlocks.push(block)
+      }
+    }
+
+    // é‡å»ºï¼šThinking -> Text/Other -> Tool
+    const newContent = [...thinkingBlocks, ...textBlocks, ...otherBlocks, ...toolBlocks]
+
+    if (newContent.length !== blocks.length || needsReorder) {
+      msg.content = newContent
+      modified = true
+
+      if (needsReorder) {
+        logger.warn('[FIX #709] Reordered assistant messages to [Thinking, Text, Tool] structure.')
+      }
+    }
+  }
+
+  return modified
+}
+
+/**
+ * åˆå¹¶è¿ç»­çš„åŒè§’è‰²æ¶ˆæ¯
+ * åœºæ™¯ï¼šå½“ä» Spec/Plan æ¨¡å¼åˆ‡æ¢å›ç¼–ç æ¨¡å¼æ—¶ï¼Œå¯èƒ½å‡ºç°è¿ç»­ä¸¤æ¡ "user" æ¶ˆæ¯
+ * è¿™ä¼šè¿åè§’è‰²äº¤æ›¿è§„åˆ™ï¼Œå¯¼è‡´ 400 æŠ¥é”™
+ * å‚è€ƒ: Antigravity-Manager FIX #813 merge_consecutive_messages
+ * @param {Array} messages - æ¶ˆæ¯åˆ—è¡¨ï¼ˆä¼šè¢«åŸåœ°ä¿®æ”¹ï¼‰
+ * @returns {boolean} æ˜¯å¦è¿›è¡Œäº†ä¿®æ”¹
+ */
+function mergeConsecutiveMessages(messages) {
+  if (!Array.isArray(messages) || messages.length <= 1) {
+    return false
+  }
+
+  const merged = []
+  let current = messages[0]
+
+  for (let i = 1; i < messages.length; i++) {
+    const next = messages[i]
+
+    if (current?.role === next?.role) {
+      // åˆå¹¶å†…å®¹
+      const currentContent = current.content
+      const nextContent = next.content
+
+      if (Array.isArray(currentContent) && Array.isArray(nextContent)) {
+        current.content = [...currentContent, ...nextContent]
+      } else if (Array.isArray(currentContent) && typeof nextContent === 'string') {
+        current.content.push({ type: 'text', text: nextContent })
+      } else if (typeof currentContent === 'string' && typeof nextContent === 'string') {
+        current.content = `${currentContent}\n\n${nextContent}`
+      } else if (typeof currentContent === 'string' && Array.isArray(nextContent)) {
+        current.content = [{ type: 'text', text: currentContent }, ...nextContent]
+      }
+    } else {
+      merged.push(current)
+      current = next
+    }
+  }
+  merged.push(current)
+
+  if (merged.length !== messages.length) {
+    messages.length = 0
+    messages.push(...merged)
+    logger.info(
+      `[FIX #813] Merged consecutive messages: ${messages.length + merged.length - messages.length} -> ${messages.length}`
+    )
+    return true
+  }
+
+  return false
+}
+
+/**
+ * å®‰å…¨æˆªæ–­ï¼ˆå°½é‡ä¸åœ¨ HTML æ ‡ç­¾ / JSON æœªé—­åˆç»“æ„ä¸­é—´æˆªæ–­ï¼‰
+ * ä»…ç”¨äº Antigravity çš„ tool_result å‹ç¼©ï¼Œé¿å…å½±å“å…¶ä»–è·¯å¾„ã€‚
+ */
+function truncateTextSafe(text, maxChars) {
   if (!text || typeof text !== 'string') {
     return ''
   }
+  if (!Number.isFinite(maxChars) || maxChars <= 0) {
+    return ''
+  }
   if (text.length <= maxChars) {
     return text
   }
-  return `${text.slice(0, maxChars)}\n...[truncated ${text.length - maxChars} chars]`
+
+  let splitPos = maxChars
+  const sub = text.slice(0, maxChars)
+
+  // 1) å°½é‡ä¸è¦æŠŠ "<...>" æ ‡ç­¾æˆªæ–­åˆ°ä¸€åŠ
+  const lastOpen = sub.lastIndexOf('<')
+  if (lastOpen >= 0) {
+    const lastClose = sub.lastIndexOf('>')
+    if (lastClose < lastOpen) {
+      splitPos = Math.min(splitPos, lastOpen)
+    }
+  }
+
+  // 2) å°½é‡ä¸è¦æŠŠ JSON å¤§æ‹¬å·æˆªæ–­åˆ°ä¸€åŠï¼ˆåªåœ¨æˆªæ–­ç‚¹é™„è¿‘æ—¶å›é€€ï¼‰
+  const lastOpenBrace = sub.lastIndexOf('{')
+  if (lastOpenBrace >= 0) {
+    const lastCloseBrace = sub.lastIndexOf('}')
+    if (lastCloseBrace < lastOpenBrace && maxChars - lastOpenBrace < 100) {
+      splitPos = Math.min(splitPos, lastOpenBrace)
+    }
+  }
+
+  const truncated = text.slice(0, splitPos)
+  const omitted = Math.max(0, text.length - splitPos)
+  return `${truncated}\n...[truncated ${omitted} chars]`
+}
+
+/**
+ * æ·±åº¦æ¸…ç† HTMLï¼ˆç§»é™¤ style/script/base64 ç­‰é«˜å™ªå£°å†…å®¹ï¼‰
+ * ä»…ç”¨äº Antigravity çš„ tool_result å‹ç¼©ï¼Œé¿å…å½±å“å…¶ä»–è·¯å¾„ã€‚
+ */
+function deepCleanHtmlForAntigravity(html) {
+  if (!html || typeof html !== 'string') {
+    return ''
+  }
+
+  let result = html
+
+  // ç§»é™¤ <style>...</style>
+  result = result.replace(/<style\b[^>]*>[\s\S]*?<\/style>/gi, '[style omitted]')
+  // ç§»é™¤ <script>...</script>
+  result = result.replace(/<script\b[^>]*>[\s\S]*?<\/script>/gi, '[script omitted]')
+  // ç§»é™¤ data:*;base64,...
+  result = result.replace(/data:[^;/]+\/[^;]+;base64,[A-Za-z0-9+/=]+/gi, '[base64 omitted]')
+  // å½’ä¸€åŒ–ç©ºè¡Œ
+  result = result.replace(/\n\s*\n/g, '\n')
+
+  return result
+}
+
+/**
+ * æ·±åº¦é€’å½’æ¸…ç† JSON ä¸­çš„ cache_control å­—æ®µ
+ * è¿™æ˜¯æœ€åä¸€é“é˜²çº¿ï¼Œç¡®ä¿å‘é€ç»™ Antigravity çš„è¯·æ±‚ä¸­ä¸åŒ…å«ä»»ä½• cache_control
+ * ç”¨äºå¤„ç†åµŒå¥—ç»“æ„å’Œéæ ‡å‡†ä½ç½®çš„ cache_control
+ * å‚è€ƒ: Antigravity-Manager FIX #593
+ * @param {Object|Array} value - å¾…æ¸…ç†çš„ JSON å¯¹è±¡
+ */
+function deepCleanCacheControl(value) {
+  if (!value || typeof value !== 'object') {
+    return
+  }
+
+  if (Array.isArray(value)) {
+    for (const item of value) {
+      deepCleanCacheControl(item)
+    }
+    return
+  }
+
+  // åˆ é™¤å½“å‰å±‚çš„ cache_control
+  if (Object.prototype.hasOwnProperty.call(value, 'cache_control')) {
+    delete value.cache_control
+  }
+
+  // é€’å½’å¤„ç†æ‰€æœ‰å­å±æ€§
+  for (const key of Object.keys(value)) {
+    deepCleanCacheControl(value[key])
+  }
 }
 
 /**
  * æˆªæ–­æ–‡æœ¬å¹¶æ·»åŠ æˆªæ–­æç¤ºï¼ˆå†…è”æ¨¡å¼ï¼Œä¸å¸¦æ¢è¡Œï¼‰
  */
@@ -260,36 +1026,44 @@ function truncateInlineText(text, maxChars) {
 /**
  * Antigravityï¼šå¯¹å·¥å…·è¾“å‡ºåšè¯­ä¹‰æ‘˜è¦ï¼ˆä¼˜å…ˆå‡å°‘ history ä½“ç§¯ï¼‰
  * ç›®æ ‡ï¼š
  * - é™ä½å›  prompt è¿‡å¤§å¯¼è‡´çš„ 429 / æ–­æµç¼º finishReason / é™çº§ end_turn æ¦‚ç‡
  * - ä¸æ”¹å˜å·¥å…·è°ƒç”¨è¯­ä¹‰ï¼ˆåªå¤„ç† tool_result æ–‡æœ¬ï¼Œä¸åŠ¨ tool_use / tool_choiceï¼‰
+ *
+ * å‹ç¼©ç­–ç•¥ï¼ˆå‚è€ƒ Antigravity-Manager tool_result_compressor.rsï¼‰ï¼š
+ * 1. å¤§æ–‡ä»¶æç¤º â†’ æå–å…³é”®ä¿¡æ¯ï¼ˆæ–‡ä»¶è·¯å¾„ã€å­—ç¬¦æ•°ï¼‰
+ * 2. æµè§ˆå™¨å¿«ç…§ â†’ å¤´éƒ¨ 70% + å°¾éƒ¨ 30% ä¿ç•™
+ * 3. å…¶ä»– â†’ ç®€å•æˆªæ–­
  */
-// âš ï¸ [dadongwo] æš‚æ—¶ç¦ç”¨æ­¤å‹ç¼©å‡½æ•°ï¼Œé¿å…å·¥å…·è¾“å‡ºä¿¡æ¯ä¸¢å¤±
-// å¦‚éœ€é‡æ–°å¯ç”¨ï¼Œç§»é™¤ä¸‹åˆ’çº¿å‰ç¼€å¹¶æ›¿æ¢ truncateText è°ƒç”¨
-function _compactToolResultTextForAntigravity(text, maxChars) {
+function compactToolResultTextForAntigravity(text, maxChars) {
   if (!text || typeof text !== 'string') {
     return ''
   }
   if (!Number.isFinite(maxChars) || maxChars <= 0) {
     return ''
   }
 
   const normalized = text.replace(/\r\n/g, '\n')
 
+  // [NEW] é’ˆå¯¹ HTML å·¥å…·è¾“å‡ºåšæ·±åº¦é¢„å¤„ç†ï¼Œå‡å°‘æ— æ„ä¹‰ token å ç”¨
+  const cleaned = /<html\b|<body\b|<!doctype\b/i.test(normalized)
+    ? deepCleanHtmlForAntigravity(normalized)
+    : normalized
+
   // 1) Claude Code å¸¸è§ï¼šå·¥å…·è¾“å‡ºè¿‡å¤§å·²å†™å…¥æ–‡ä»¶ã€‚è¯¥æç¤ºæœ¬èº«å¯èƒ½å¾ˆé•¿ä¸”ä¼šåå¤æ»šå…¥ historyã€‚
   const savedOutputRegex =
     /result\s*\(\s*(?<count>[\d,]+)\s*characters\s*\)\s*exceeds\s+maximum\s+allowed\s+tokens\.\s*Output\s+(?:has\s+been\s+)?saved\s+to\s+(?<path>[^\r\n]+)/i
-  const savedMatch = savedOutputRegex.exec(normalized)
+  const savedMatch = savedOutputRegex.exec(cleaned)
   if (savedMatch) {
     const rawPath = String(savedMatch?.groups?.path || '').trim()
     const filePath = rawPath
       .replace(/[)\]"']+$/, '')
       .replace(/\.$/, '')
       .trim()
     const count = String(savedMatch?.groups?.count || '').trim()
 
-    const lines = normalized.split('\n').map((l) => l.trim())
+    const lines = cleaned.split('\n').map((l) => l.trim())
     const noticeLine =
       lines.find((l) => /exceeds maximum allowed tokens/i.test(l) && /saved to/i.test(l)) ||
       `result (${count || 'N/A'} characters) exceeds maximum allowed tokens. Output has been saved to ${filePath}`
 
     const formatLine =
@@ -304,43 +1078,43 @@ function _compactToolResultTextForAntigravity(text, maxChars) {
       filePath
         ? `[tool_result omitted to reduce prompt size; read file locally if needed: ${filePath}]`
         : '[tool_result omitted to reduce prompt size; read the saved file locally if needed]'
     ].filter(Boolean)
 
-    return truncateText(compactLines.join('\n'), maxChars)
+    return truncateTextSafe(compactLines.join('\n'), maxChars)
   }
 
   // 2) æµè§ˆå™¨å¿«ç…§ç±»ï¼šå¸¸è§ä¸ºè¶…å¤§æ–‡æœ¬ï¼ˆPage Snapshot / ref=...ï¼‰ï¼Œä¼šæŠŠ history æ’‘çˆ†ã€‚
   //    ä¸ºäº†å°½é‡ä¸å½±å“å¯ç”¨æ€§ï¼Œé‡‡ç”¨â€œå¤´+å°¾ä¿ç•™â€çš„æ–¹å¼ï¼Œåªåœ¨æ˜æ˜¾è¶…å¤§æ—¶è§¦å‘ã€‚
-  if (normalized.length > 20000) {
+  if (cleaned.length > 20000) {
     const looksLikeSnapshot =
-      /page snapshot|é¡µé¢å¿«ç…§/i.test(normalized) ||
-      (normalized.match(/\bref\s*[=:]\s*['"]?[a-z0-9_-]{2,}/gi) || []).length > 30 ||
-      (normalized.match(/\[ref=/gi) || []).length > 30
+      /page snapshot|é¡µé¢å¿«ç…§/i.test(cleaned) ||
+      (cleaned.match(/\bref\s*[=:]\s*['"]?[a-z0-9_-]{2,}/gi) || []).length > 30 ||
+      (cleaned.match(/\[ref=/gi) || []).length > 30
 
     if (!looksLikeSnapshot) {
-      return truncateText(text, maxChars)
+      return truncateTextSafe(cleaned, maxChars)
     }
 
     const desiredMax = Math.min(maxChars, 16000)
-    if (desiredMax >= 2000 && normalized.length > desiredMax) {
-      const meta = `[page snapshot summarized to reduce prompt size; original ${normalized.length} chars]`
+    if (desiredMax >= 2000 && cleaned.length > desiredMax) {
+      const meta = `[page snapshot summarized to reduce prompt size; original ${cleaned.length} chars]`
       const overhead = meta.length + 200
       const budget = Math.max(0, desiredMax - overhead)
       if (budget >= 1000) {
         const headLen = Math.min(10000, Math.max(500, Math.floor(budget * 0.7)))
         const tailLen = Math.min(3000, Math.max(0, budget - headLen))
-        const head = normalized.slice(0, headLen)
-        const tail = tailLen > 0 ? normalized.slice(-tailLen) : ''
-        const omitted = Math.max(0, normalized.length - headLen - tailLen)
+        const head = cleaned.slice(0, headLen)
+        const tail = tailLen > 0 ? cleaned.slice(-tailLen) : ''
+        const omitted = Math.max(0, cleaned.length - headLen - tailLen)
         const summarized = `${meta}\n---[HEAD]---\n${head}\n---[...omitted ${omitted} chars]---\n---[TAIL]---\n${tail}`
-        return truncateText(summarized, maxChars)
+        return truncateTextSafe(summarized, maxChars)
       }
     }
   }
 
-  return truncateText(text, maxChars)
+  return truncateTextSafe(cleaned, maxChars)
 }
 
 /**
  * å‹ç¼©å·¥å…·é¡¶çº§æè¿°
  * å–å‰ 6 è¡Œï¼Œåˆå¹¶ä¸ºå•è¡Œï¼Œæˆªæ–­åˆ° 400 å­—ç¬¦
@@ -567,14 +1341,13 @@ function sanitizeToolResultBlocksForAntigravity(blocks) {
     if (block.type === 'text' && typeof block.text === 'string') {
       const remaining = MAX_ANTIGRAVITY_TOOL_RESULT_CHARS - usedChars
       if (remaining <= 0) {
         break
       }
-      // âš ï¸ [dadongwo] ä½¿ç”¨ç®€å•æˆªæ–­è€Œéè¯­ä¹‰å‹ç¼©ï¼Œä¿ç•™æ›´å¤šå·¥å…·è¾“å‡ºç»†èŠ‚
-      // å¦‚éœ€å¯ç”¨è¯­ä¹‰å‹ç¼©ï¼ˆå‡å°‘ prompt ä½“ç§¯ï¼‰ï¼Œå–æ¶ˆä¸‹æ–¹æ³¨é‡Šï¼š
-      // const text = _compactToolResultTextForAntigravity(block.text, remaining)
-      const text = truncateText(block.text, remaining)
+      // [ENABLED] ä½¿ç”¨è¯­ä¹‰å‹ç¼©å‡å°‘ prompt ä½“ç§¯ï¼Œé™ä½ 429/æ–­æµæ¦‚ç‡
+      // å‚è€ƒ: Antigravity-Manager tool_result_compressor.rs
+      const text = compactToolResultTextForAntigravity(block.text, remaining)
 
       cleaned.push({ ...block, text })
       usedChars += text.length
       continue
     }
@@ -609,14 +1382,13 @@ function normalizeToolResultContent(content, { vendor = null } = {}) {
   if (content === null || content === undefined) {
     return ''
   }
   if (typeof content === 'string') {
     if (vendor === 'antigravity') {
-      // âš ï¸ [dadongwo] ä½¿ç”¨ç®€å•æˆªæ–­è€Œéè¯­ä¹‰å‹ç¼©ï¼Œä¿ç•™æ›´å¤šå·¥å…·è¾“å‡ºç»†èŠ‚
-      // å¦‚éœ€å¯ç”¨è¯­ä¹‰å‹ç¼©ï¼Œå–æ¶ˆä¸‹æ–¹æ³¨é‡Šï¼š
-      // return _compactToolResultTextForAntigravity(content, MAX_ANTIGRAVITY_TOOL_RESULT_CHARS)
-      return truncateText(content, MAX_ANTIGRAVITY_TOOL_RESULT_CHARS)
+      // [ENABLED] ä½¿ç”¨è¯­ä¹‰å‹ç¼©å‡å°‘ prompt ä½“ç§¯ï¼Œé™ä½ 429/æ–­æµæ¦‚ç‡
+      // å‚è€ƒ: Antigravity-Manager tool_result_compressor.rs
+      return compactToolResultTextForAntigravity(content, MAX_ANTIGRAVITY_TOOL_RESULT_CHARS)
     }
     return content
   }
   // Claude Code çš„ tool_result.content é€šå¸¸æ˜¯ content blocks æ•°ç»„ï¼ˆä¾‹å¦‚ [{type:"text",text:"..."}]ï¼‰ã€‚
   // [dadongwo] ä¿ç•™åŸå§‹ JSON ç»“æ„ï¼ˆæ•°ç»„/å¯¹è±¡ï¼‰ï¼Œé¿å…ä¸Šæ¸¸å°†å…¶è§†ä¸ºâ€œæ— æ•ˆ tool_resultâ€ä»è€Œè§¦å‘ 400ã€‚
@@ -992,11 +1764,29 @@ function convertAnthropicToolsToGeminiTools(tools, { vendor = null } = {}) {
     }
 
     return sanitized
   }
 
-  const functionDeclarations = tools
+  // [FIX] æ£€æµ‹æ˜¯å¦æœ‰ web_search / googleSearch ç±»å‹çš„æœåŠ¡å™¨å·¥å…·
+  // Claude API ä¸­çš„ web_search å·¥å…·å¯èƒ½æœ‰ä»¥ä¸‹å½¢å¼ï¼š
+  // - type: "web_search_20250305" æˆ–ç±»ä¼¼
+  // - name: "web_search" / "google_search"
+  const isWebSearchTool = (tool) => {
+    if (!tool) {
+      return false
+    }
+    const toolType = tool.type || ''
+    const toolName = tool.name || ''
+    return (
+      toolType.includes('web_search') || toolName === 'web_search' || toolName === 'google_search'
+    )
+  }
+
+  const hasWebSearchTool = tools.some(isWebSearchTool)
+  const nonWebSearchTools = tools.filter((t) => !isWebSearchTool(t))
+
+  const functionDeclarations = nonWebSearchTools
     .map((tool) => {
       const toolDef = tool?.custom && typeof tool.custom === 'object' ? tool.custom : tool
       if (!toolDef || !toolDef.name) {
         return null
       }
@@ -1027,19 +1817,29 @@ function convertAnthropicToolsToGeminiTools(tools, { vendor = null } = {}) {
       }
       return { ...baseDecl, parameters: schema }
     })
     .filter(Boolean)
 
-  if (functionDeclarations.length === 0) {
-    return null
+  // [FIX] è§£å†³ "Multiple tools are supported only when they are all search tools" 400 é”™è¯¯
+  // Gemini v1internal æ¥å£ä¸å…è®¸åœ¨åŒä¸€ä¸ªå·¥å…·å®šä¹‰ä¸­æ··ç”¨ Google Search å’Œ Function Declarations
+  // å‚è€ƒ: Antigravity-Manager request.rs
+  if (functionDeclarations.length > 0) {
+    // å¦‚æœæœ‰æœ¬åœ°å·¥å…·ï¼ˆfunctionDeclarationsï¼‰ï¼Œåˆ™åªä½¿ç”¨æœ¬åœ°å·¥å…·ï¼Œæ”¾å¼ƒ googleSearch
+    if (hasWebSearchTool) {
+      logger.info(
+        `âš ï¸ [Tool-Conflict] Skipping googleSearch injection due to ${functionDeclarations.length} existing function declarations. Gemini v1internal does not support mixed tool types.`
+      )
+    }
+    return [{ functionDeclarations }]
   }
 
-  return [
-    {
-      functionDeclarations
-    }
-  ]
+  // å¦‚æœåªæœ‰ web_search æ²¡æœ‰å…¶ä»–æœ¬åœ°å·¥å…·ï¼Œè¿”å› googleSearch
+  if (hasWebSearchTool) {
+    return [{ googleSearch: {} }]
+  }
+
+  return null
 }
 
 /**
  * å°† Anthropic çš„ tool_choice è½¬æ¢ä¸º Gemini çš„ toolConfig
  * æ˜ å°„å…³ç³»ï¼š
@@ -1112,11 +1912,11 @@ function convertAnthropicToolChoiceToGeminiToolConfig(toolChoice) {
  * @returns {Array} Gemini æ ¼å¼çš„ contents
  */
 function convertAnthropicMessagesToGeminiContents(
   messages,
   toolUseIdToName,
-  { vendor = null, stripThinking = false, sessionId = null } = {}
+  { vendor = null, stripThinking = false, sessionId = null, targetModel = null } = {}
 ) {
   const contents = []
   for (const message of messages || []) {
     const role = message?.role === 'assistant' ? 'model' : 'user'
 
@@ -1160,10 +1960,27 @@ function convertAnthropicMessagesToGeminiContents(
               if (cachedSig) {
                 signature = cachedSig
                 logger.debug('[SignatureCache] Restored signature from cache for thinking block')
               }
             }
+
+            // [NEW] è·¨æ¨¡å‹å…¼å®¹æ€§æ£€æŸ¥
+            // æ£€æŸ¥ç­¾åæ˜¯å¦æ¥è‡ªå…¼å®¹çš„æ¨¡å‹å®¶æ—ï¼Œé˜²æ­¢è·¨æ¨¡å‹ç­¾åé”™è¯¯
+            if (signature && targetModel) {
+              const cachedFamily = signatureCache.getSignatureFamily(signature)
+              if (cachedFamily && !isModelCompatible(cachedFamily, targetModel)) {
+                logger.warn(
+                  `âš ï¸ [Thinking-Compatibility] Incompatible signature detected (Family: ${cachedFamily}, Target: ${targetModel}). Dropping signature.`
+                )
+                // ä¸¢å¼ƒä¸å…¼å®¹çš„ç­¾åï¼Œå°† thinking é™çº§ä¸ºæ™®é€šæ–‡æœ¬
+                if (hasThinkingText) {
+                  parts.push({ text: thinkingText })
+                }
+                continue
+              }
+            }
+
             const hasSignature = Boolean(signature)
 
             // Claude Code æœ‰æ—¶ä¼šå‘é€ç©ºçš„ thinking blockï¼ˆæ—  thinking / æ—  signatureï¼‰ã€‚
             // ä¼ ç»™ Antigravity ä¼šå˜æˆä»…å« thoughtSignature çš„ partï¼Œå®¹æ˜“è§¦å‘ INVALID_ARGUMENTã€‚
             if (!hasThinkingText && !hasSignature) {
@@ -1388,11 +2205,49 @@ function canEnableAntigravityThinking(messages) {
 function buildGeminiRequestFromAnthropic(
   body,
   baseModel,
   { vendor = null, sessionId = null } = {}
 ) {
-  const normalizedMessages = normalizeAnthropicMessages(body.messages || [], { vendor })
+  // ========================================================================
+  // [NEW] é¢„å¤„ç†é˜¶æ®µï¼šæ¶ˆæ¯æ¸…ç†å’Œä¼˜åŒ–
+  // å‚è€ƒ: Antigravity-Manager v3.3.45
+  // ========================================================================
+
+  // å¤åˆ¶æ¶ˆæ¯åˆ—è¡¨ä»¥é¿å…ä¿®æ”¹åŸå§‹æ•°æ®
+  const messages = JSON.parse(JSON.stringify(body.messages || []))
+
+  // [FIX #813] åˆå¹¶è¿ç»­çš„åŒè§’è‰²æ¶ˆæ¯
+  // ç¡®ä¿è¯·æ±‚ç¬¦åˆ Anthropic å’Œ Gemini çš„è§’è‰²äº¤æ›¿åè®®
+  mergeConsecutiveMessages(messages)
+
+  // [FIX #709] é¢„æ’åº thinking blocks
+  // ç¡®ä¿ assistant æ¶ˆæ¯ä¸­çš„ thinking blocks å§‹ç»ˆåœ¨æœ€å‰é¢
+  sortThinkingBlocksFirst(messages)
+
+  // [NEW] ContextManager: ä¸Šä¸‹æ–‡å‹åŠ›æ£€æµ‹å’Œå†å²å‡€åŒ–
+  // ä»…å¯¹ Antigravity vendor å¯ç”¨ï¼ˆå› ä¸ºå®ƒå¯¹ prompt é•¿åº¦æ›´æ•æ„Ÿï¼‰
+  if (vendor === 'antigravity') {
+    // ç¡®å®šä¸Šä¸‹æ–‡é™åˆ¶ï¼ˆFlash: ~1M, Pro: ~2Mï¼‰
+    const contextLimit = baseModel?.toLowerCase().includes('flash') ? 1000000 : 2000000
+    const estimatedUsage = estimateTokenUsage({ ...body, messages })
+    const usageRatio = estimatedUsage / contextLimit
+
+    const strategy = determinePurificationStrategy(usageRatio)
+    if (strategy !== PurificationStrategy.None) {
+      logger.info(
+        `[ContextManager] Context pressure: ${(usageRatio * 100).toFixed(1)}% (${estimatedUsage} / ${contextLimit}), Strategy: ${strategy}`
+      )
+      purifyHistoryThinking(messages, strategy)
+    }
+
+    // [NEW] å·¥å…·å¾ªç¯ä¿®å¤
+    // æ£€æµ‹å¹¶ä¿®å¤æ–­è£‚çš„å·¥å…·å¾ªç¯ï¼Œé¿å… "Assistant message must start with thinking" é”™è¯¯
+    closeToolLoopForThinking(messages)
+  }
+
+  // ä½¿ç”¨é¢„å¤„ç†åçš„æ¶ˆæ¯è¿›è¡Œåç»­è½¬æ¢
+  const normalizedMessages = normalizeAnthropicMessages(messages, { vendor })
   const toolUseIdToName = buildToolUseIdToNameMap(normalizedMessages || [])
 
   // æå‰åˆ¤æ–­æ˜¯å¦å¯ä»¥å¯ç”¨ thinkingï¼Œä»¥ä¾¿å†³å®šæ˜¯å¦éœ€è¦å‰¥ç¦» thinking blocks
   let canEnableThinking = false
   if (vendor === 'antigravity' && body?.thinking?.type === 'enabled') {
@@ -1407,11 +2262,12 @@ function buildGeminiRequestFromAnthropic(
     toolUseIdToName,
     {
       vendor,
       // å½“ Antigravity æ— æ³•å¯ç”¨ thinking æ—¶ï¼Œå‰¥ç¦»æ‰€æœ‰ thinking blocks
       stripThinking: vendor === 'antigravity' && !canEnableThinking,
-      sessionId
+      sessionId,
+      targetModel: baseModel // ç”¨äºç­¾åå…¼å®¹æ€§æ£€æŸ¥
     }
   )
   const systemParts = buildSystemParts(body.system)
 
   if (vendor === 'antigravity' && isEnvEnabled(process.env[TOOL_ERROR_CONTINUE_ENV])) {
@@ -1477,10 +2333,17 @@ function buildGeminiRequestFromAnthropic(
     // Anthropic çš„é»˜è®¤è¯­ä¹‰æ˜¯ tools å­˜åœ¨ä¸”æœªè®¾ç½® tool_choice æ—¶ä¸º autoã€‚
     // Gemini/Antigravity çš„ function calling é»˜è®¤å¯èƒ½ä¸ä¼šå¯ç”¨ï¼Œå› æ­¤æ˜¾å¼è®¾ç½®ä¸º AUTOï¼Œé¿å…â€œæ°¸è¿œä¸äº§å‡º tool_useâ€ã€‚
     geminiRequestBody.toolConfig = { functionCallingConfig: { mode: 'AUTO' } }
   }
 
+  // [FIX #593] æœ€åä¸€é“é˜²çº¿ï¼šé€’å½’æ·±åº¦æ¸…ç†æ‰€æœ‰ cache_control å­—æ®µ
+  // ç¡®ä¿å‘é€ç»™ Antigravity/Gemini çš„è¯·æ±‚ä¸­ä¸åŒ…å«ä»»ä½• cache_control
+  // VS Code æ’ä»¶ç­‰å®¢æˆ·ç«¯å¯èƒ½åœ¨å¤šè½®å¯¹è¯ä¸­å°†å†å²æ¶ˆæ¯çš„ cache_control å­—æ®µåŸå°ä¸åŠ¨å‘å›
+  if (vendor === 'antigravity') {
+    deepCleanCacheControl(geminiRequestBody)
+  }
+
   return { model: baseModel, request: geminiRequestBody }
 }
 
 // ============================================================================
 // è¾…åŠ©å‡½æ•°ï¼šGemini å“åº”è§£æ
@@ -1835,10 +2698,53 @@ function stripToolsFromRequest(requestData) {
   delete nextRequest.request.tools
   delete nextRequest.request.toolConfig
   return nextRequest
 }
 
+function parseAntigravity429Meta(error) {
+  const body = error?.response?.data
+  const reason = parseGoogleErrorReason(body) || null
+  const retryDelayMs = parseGoogleRetryDelayMs(body)
+  return { reason, retryDelayMs: retryDelayMs || null }
+}
+
+function bumpAntigravityQuotaStrike(accountId) {
+  const key = String(accountId || '').trim()
+  if (!key) {
+    return 1
+  }
+
+  const now = Date.now()
+  const existing = antigravityQuotaStrikesByAccountId.get(key)
+  const isFresh = existing && now - (existing.lastAtMs || 0) <= ANTIGRAVITY_QUOTA_STRIKE_TTL_MS
+  const nextCount = Math.min(
+    ANTIGRAVITY_QUOTA_LOCKOUT_SECONDS.length,
+    (isFresh ? existing.count || 0 : 0) + 1
+  )
+
+  antigravityQuotaStrikesByAccountId.set(key, { count: nextCount, lastAtMs: now })
+  return nextCount
+}
+
+function resolveAntigravityAccountRateLimitSeconds({ accountId, reason, retryDelayMs }) {
+  const parsedSeconds =
+    retryDelayMs && retryDelayMs > 0 ? Math.max(1, Math.ceil(retryDelayMs / 1000)) : null
+
+  if (reason === 'RATE_LIMIT_EXCEEDED') {
+    return Math.max(ANTIGRAVITY_DEFAULT_RATE_LIMIT_SECONDS, parsedSeconds || 0)
+  }
+
+  if (reason === 'QUOTA_EXHAUSTED') {
+    const strike = bumpAntigravityQuotaStrike(accountId)
+    const idx = Math.min(strike - 1, ANTIGRAVITY_QUOTA_LOCKOUT_SECONDS.length - 1)
+    const base = ANTIGRAVITY_QUOTA_LOCKOUT_SECONDS[idx]
+    return Math.max(base, parsedSeconds || 0)
+  }
+
+  return null
+}
+
 /**
  * å†™å…¥ Anthropic SSE äº‹ä»¶
  * å°†äº‹ä»¶å’Œæ•°æ®ä»¥ SSE æ ¼å¼å‘é€ç»™å®¢æˆ·ç«¯
  */
 function writeAnthropicSseEvent(res, event, data) {
@@ -2104,47 +3010,58 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
           logger.warn('âš ï¸ Tool schema rejected by upstream, retrying without tools', {
             vendor,
             accountId
           })
           rawResponse = await attemptRequest(stripToolsFromRequest(requestData))
-        } else if (
-          // [429 è´¦æˆ·åˆ‡æ¢] æ£€æµ‹åˆ° Antigravity é…é¢è€—å°½é”™è¯¯æ—¶ï¼Œå°è¯•åˆ‡æ¢è´¦æˆ·é‡è¯•
-          vendor === 'antigravity' &&
-          sanitized.statusCode === 429 &&
-          (sanitized.message?.toLowerCase()?.includes('exhausted') ||
-            sanitized.upstreamMessage?.toLowerCase()?.includes('exhausted') ||
-            sanitized.message?.toLowerCase()?.includes('capacity'))
-        ) {
+        } else if (vendor === 'antigravity' && sanitized.statusCode === 429) {
+          const { reason, retryDelayMs } = parseAntigravity429Meta(error)
+          const resetsInSeconds = resolveAntigravityAccountRateLimitSeconds({
+            accountId,
+            reason,
+            retryDelayMs
+          })
+
+          if (!resetsInSeconds) {
+            throw error
+          }
+
           logger.warn(
-            'âš ï¸ Antigravity 429 quota exhausted (non-stream), switching account and retrying',
+            'âš ï¸ Antigravity 429 rate limited (non-stream), switching account and retrying',
             {
               vendor,
               accountId,
-              model: effectiveModel
+              model: effectiveModel,
+              reason,
+              resetsInSeconds
             }
           )
-          // åˆ é™¤å½“å‰ä¼šè¯æ˜ å°„ï¼Œè®©è°ƒåº¦å™¨é€‰æ‹©å…¶ä»–è´¦æˆ·
-          if (sessionHash) {
-            await unifiedGeminiScheduler._deleteSessionMapping(sessionHash)
+
+          try {
+            await unifiedGeminiScheduler.markAccountRateLimited(
+              accountId,
+              'gemini',
+              sessionHash,
+              resetsInSeconds
+            )
+          } catch (limitError) {
+            logger.warn('Failed to mark Gemini account as rate limited (antigravity):', limitError)
           }
-          // é‡æ–°é€‰æ‹©è´¦æˆ·
+
           try {
             const newAccountSelection = await unifiedGeminiScheduler.selectAccountForApiKey(
               req.apiKey,
               sessionHash,
               effectiveModel,
               { oauthProvider: vendor }
             )
             const newAccountId = newAccountSelection.accountId
 
-            // âœ¨ å¤§ä¸œä¿®å¤ï¼šæ‰‹åŠ¨è·å–è´¦å·å¹¶æ„å»º Clientï¼Œä¿æŒé€»è¾‘ä¸€è‡´æ€§
             const newAccount = await geminiAccountService.getAccount(newAccountId)
             if (!newAccount) {
               throw new Error(`Retry account not found: ${newAccountId}`)
             }
 
-            // é‡æ–°å¤„ç† Proxy é…ç½®
             let newProxyConfig = null
             if (newAccount.proxy) {
               try {
                 newProxyConfig =
                   typeof newAccount.proxy === 'string'
@@ -2153,11 +3070,10 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
               } catch (e) {
                 logger.warn('Failed to parse proxy configuration for retry:', e)
               }
             }
 
-            // æ„å»ºæ–°çš„ Client
             const newClient = await geminiAccountService.getOauthClient(
               newAccount.accessToken,
               newAccount.refreshToken,
               newProxyConfig,
               newAccount.oauthProvider
@@ -2165,20 +3081,19 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
 
             if (!newClient) {
               throw new Error('Failed to get new Gemini client for retry')
             }
 
-            // è·å–æ–°è´¦æˆ·çš„ projectId
             let newProjectId = newAccount.projectId
             if (vendor === 'antigravity') {
               newProjectId = ensureAntigravityProjectId(newAccount)
             }
 
             logger.info(
               `ğŸ”„ Retrying non-stream with new account: ${newAccountId} (was: ${accountId})`
             )
-            // ç”¨æ–°è´¦æˆ·çš„ client é‡è¯•
+
             rawResponse =
               vendor === 'antigravity'
                 ? await geminiAccountService.generateContentAntigravity(
                     newClient,
                     requestData,
@@ -2193,15 +3108,15 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
                     null,
                     newProjectId,
                     upstreamSessionId,
                     newProxyConfig
                   )
-            // æ›´æ–° accountId ä»¥ä¾¿åç»­ä½¿ç”¨è®°å½•
+
             accountId = newAccountId
           } catch (retryError) {
             logger.error('âŒ Failed to retry non-stream with new account:', retryError)
-            throw error // æŠ›å‡ºåŸå§‹é”™è¯¯
+            throw error
           }
         } else {
           throw error
         }
       }
@@ -2322,18 +3237,28 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
 
       return res.status(200).json(responseBody)
     } catch (error) {
       const sanitized = sanitizeUpstreamError(error)
       logger.error('Upstream Gemini error (via /v1/messages):', sanitized)
+      const statusCode = sanitized.statusCode || 502
+      if (!res.headersSent && statusCode === 429) {
+        const retryAfter =
+          error?.response?.headers?.['retry-after'] ||
+          error?.response?.headers?.['Retry-After'] ||
+          null
+        if (retryAfter) {
+          res.setHeader('Retry-After', String(retryAfter))
+        }
+      }
       dumpAnthropicNonStreamResponse(
         req,
-        sanitized.statusCode || 502,
+        statusCode,
         buildAnthropicError(sanitized.upstreamMessage || sanitized.message),
         { vendor, accountId, effectiveModel, forcedVendor: vendor, upstreamError: sanitized }
       )
       return res
-        .status(sanitized.statusCode || 502)
+        .status(statusCode)
         .json(buildAnthropicError(sanitized.upstreamMessage || sanitized.message))
     }
   }
 
   const messageId = `msg_${crypto.randomBytes(12).toString('hex')}`
@@ -2372,38 +3297,50 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
         logger.warn('âš ï¸ Tool schema rejected by upstream, retrying stream without tools', {
           vendor,
           accountId
         })
         streamResponse = await startStream(stripToolsFromRequest(requestData))
-      } else if (
-        // [429 è´¦æˆ·åˆ‡æ¢] æ£€æµ‹åˆ° Antigravity é…é¢è€—å°½é”™è¯¯æ—¶ï¼Œå°è¯•åˆ‡æ¢è´¦æˆ·é‡è¯•
-        vendor === 'antigravity' &&
-        sanitized.statusCode === 429 &&
-        (sanitized.message?.toLowerCase()?.includes('exhausted') ||
-          sanitized.upstreamMessage?.toLowerCase()?.includes('exhausted') ||
-          sanitized.message?.toLowerCase()?.includes('capacity'))
-      ) {
-        logger.warn('âš ï¸ Antigravity 429 quota exhausted, switching account and retrying', {
+      } else if (vendor === 'antigravity' && sanitized.statusCode === 429) {
+        const { reason, retryDelayMs } = parseAntigravity429Meta(error)
+        const resetsInSeconds = resolveAntigravityAccountRateLimitSeconds({
+          accountId,
+          reason,
+          retryDelayMs
+        })
+
+        if (!resetsInSeconds) {
+          throw error
+        }
+
+        logger.warn('âš ï¸ Antigravity 429 rate limited, switching account and retrying', {
           vendor,
           accountId,
-          model: effectiveModel
+          model: effectiveModel,
+          reason,
+          resetsInSeconds
         })
-        // åˆ é™¤å½“å‰ä¼šè¯æ˜ å°„ï¼Œè®©è°ƒåº¦å™¨é€‰æ‹©å…¶ä»–è´¦æˆ·
-        if (sessionHash) {
-          await unifiedGeminiScheduler._deleteSessionMapping(sessionHash)
+
+        try {
+          await unifiedGeminiScheduler.markAccountRateLimited(
+            accountId,
+            'gemini',
+            sessionHash,
+            resetsInSeconds
+          )
+        } catch (limitError) {
+          logger.warn('Failed to mark Gemini account as rate limited (antigravity):', limitError)
         }
-        // é‡æ–°é€‰æ‹©è´¦æˆ·
+
         try {
           const newAccountSelection = await unifiedGeminiScheduler.selectAccountForApiKey(
             req.apiKey,
             sessionHash,
             effectiveModel,
             { oauthProvider: vendor }
           )
           const newAccountId = newAccountSelection.accountId
 
-          // âœ¨ å¤§ä¸œä¿®å¤ï¼šè¿™é‡Œä¹Ÿè¦ä¿æŒä¸€è‡´
           const newAccount = await geminiAccountService.getAccount(newAccountId)
           if (!newAccount) {
             throw new Error(`Retry account not found: ${newAccountId}`)
           }
 
@@ -2428,18 +3365,17 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
 
           if (!newClient) {
             throw new Error('Failed to get new Gemini client for retry')
           }
 
-          // è·å–æ–°è´¦æˆ·çš„ projectId
           let newProjectId = newAccount.projectId
           if (vendor === 'antigravity') {
             newProjectId = ensureAntigravityProjectId(newAccount)
           }
 
           logger.info(`ğŸ”„ Retrying with new account: ${newAccountId} (was: ${accountId})`)
-          // ç”¨æ–°è´¦æˆ·çš„ client é‡è¯•
+
           streamResponse =
             vendor === 'antigravity'
               ? await geminiAccountService.generateContentStreamAntigravity(
                   newClient,
                   requestData,
@@ -2456,15 +3392,15 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
                   newProjectId,
                   upstreamSessionId,
                   abortController.signal,
                   newProxyConfig
                 )
-          // æ›´æ–° accountId ä»¥ä¾¿åç»­ä½¿ç”¨è®°å½•
+
           accountId = newAccountId
         } catch (retryError) {
           logger.error('âŒ Failed to retry with new account:', retryError)
-          throw error // æŠ›å‡ºåŸå§‹é”™è¯¯
+          throw error
         }
       } else {
         throw error
       }
     }
@@ -2502,10 +3438,23 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
     // ========================================================================
     // [å¤§ä¸œçš„ 2.0 è¡¥ä¸ - ä¿®å¤ç‰ˆ] æ´»è·ƒåº¦çœ‹é—¨ç‹— (Watchdog)
     // ========================================================================
     let activityTimeout = null
     const STREAM_ACTIVITY_TIMEOUT_MS = 45000 // 45ç§’æ— æ•°æ®è§†ä¸ºå¡æ­»
+    const STREAM_FIRST_BYTE_TIMEOUT_MS = isAntigravityVendor
+      ? (() => {
+          const raw = process.env.ANTIGRAVITY_STREAM_FIRST_BYTE_TIMEOUT_MS
+          const parsed = parseInt(String(raw || ''), 10)
+          if (!Number.isFinite(parsed) || Number.isNaN(parsed) || parsed <= 0) {
+            return 15000
+          }
+          return parsed
+        })()
+      : 0
+
+    let firstByteTimeout = null
+    let receivedAnyUpstreamBytes = false
 
     const resetActivityTimeout = () => {
       if (activityTimeout) {
         clearTimeout(activityTimeout)
       }
@@ -2523,10 +3472,15 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
 
         if (!abortController.signal.aborted) {
           abortController.abort()
         }
 
+        if (firstByteTimeout) {
+          clearTimeout(firstByteTimeout)
+          firstByteTimeout = null
+        }
+
         writeAnthropicSseEvent(res, 'error', {
           type: 'error',
           error: {
             type: 'overloaded_error',
             message: 'Upstream stream timed out (zombie connection). Please try again.'
@@ -2536,10 +3490,38 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
       }, STREAM_ACTIVITY_TIMEOUT_MS)
     }
 
     // ğŸ”¥ã€è¿™é‡Œï¼ã€‘ä¸€å®šè¦åŠ è¿™å¥æ¥å¯åŠ¨å®ƒï¼
     resetActivityTimeout()
+
+    // Antigravity ä¸“ç”¨ï¼šé¦–åŒ…æ¢æµ‹ï¼Œé¿å…â€œæ¡æ‰‹æˆåŠŸä½†é•¿æœŸæ— ä»»ä½•å­—èŠ‚â€çš„å‡æµå¡ä½ã€‚
+    if (isAntigravityVendor && STREAM_FIRST_BYTE_TIMEOUT_MS > 0) {
+      firstByteTimeout = setTimeout(() => {
+        if (finished || receivedAnyUpstreamBytes) {
+          return
+        }
+
+        finished = true
+        logger.warn('âš ï¸ Antigravity upstream stream no first byte, forcing termination.', {
+          requestId: req.requestId,
+          timeoutMs: STREAM_FIRST_BYTE_TIMEOUT_MS
+        })
+
+        if (!abortController.signal.aborted) {
+          abortController.abort()
+        }
+
+        writeAnthropicSseEvent(res, 'error', {
+          type: 'error',
+          error: {
+            type: 'overloaded_error',
+            message: 'Upstream stream timed out before first byte. Please try again.'
+          }
+        })
+        res.end()
+      }, STREAM_FIRST_BYTE_TIMEOUT_MS)
+    }
     // ========================================================================
 
     let buffer = ''
     let emittedText = ''
     let emittedThinking = ''
@@ -2554,10 +3536,12 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
     let rescueAttempted = false
     let forcedRescueAttempted = false
     const emittedToolCallKeys = new Set()
     const emittedToolUseNames = new Set()
     const pendingToolCallsById = new Map()
+    let mcpXmlBuffer = ''
+    let inMcpXml = false
 
     const extractPlannedToolAliasFromTodoWrite = (messages) => {
       if (!Array.isArray(messages)) {
         return null
       }
@@ -2694,10 +3678,16 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
       }
       return false
     }
 
     const emitToolUseBlock = (name, args, id = null) => {
+      // [NEW] å‚æ•°é‡æ˜ å°„ï¼šä¿®å¤ Gemini è¿”å›çš„å·¥å…·è°ƒç”¨å‚æ•°
+      // åœ¨å‘å‡ºå·¥å…·è°ƒç”¨ä¹‹å‰åº”ç”¨ä¿®å¤ï¼Œç¡®ä¿ Claude Code èƒ½æ­£ç¡®å¤„ç†
+      if (args && typeof args === 'object') {
+        remapFunctionCallArgs(name, args)
+      }
+
       const toolUseId = typeof id === 'string' && id ? id : buildToolUseId()
       const jsonArgs = stableJsonStringify(args || {})
 
       if (name) {
         emittedToolUseNames.add(name)
@@ -2769,10 +3759,111 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
       }
 
       return { args: null, json, canContinue }
     }
 
+    /**
+     * MCP XML Bridgeï¼ˆä»…ç”¨äºæµå¼ text_deltaï¼‰ï¼š
+     * å°†æ–‡æœ¬ä¸­çš„ <mcp__xxx>{...}</mcp__xxx> è½¬æ¢ä¸º tool_useï¼Œé¿å… Claude Code æŠŠâ€œå·¥å…·æ ‡ç­¾â€å½“æ™®é€šæ–‡æœ¬åæ‰ã€‚
+     *
+     * è®¾è®¡è¦ç‚¹ï¼š
+     * - åªåœ¨å‘½ä¸­ "<mcp__" æ—¶å¯åŠ¨ç¼“å†²ï¼›ä¸å½±å“æ™®é€šæ–‡æœ¬è·¯å¾„ã€‚
+     * - æ ‡ç­¾ä¸å®Œæ•´æ—¶ç¼“å†²ç­‰å¾…åç»­ deltaï¼›ç¼“å†²è¿‡å¤§åˆ™é™çº§ä¸ºåŸæ–‡è¾“å‡ºï¼Œé¿å…å¡æ­»ã€‚
+     */
+    const processMcpXmlBridgeDelta = (deltaText) => {
+      if (!deltaText || typeof deltaText !== 'string') {
+        return []
+      }
+
+      const actions = []
+      const MAX_BUFFER_CHARS = 65536
+
+      const appendToBuffer = (s) => {
+        if (!s) {
+          return
+        }
+        mcpXmlBuffer += s
+        if (mcpXmlBuffer.length > MAX_BUFFER_CHARS) {
+          actions.push({ type: 'text', text: mcpXmlBuffer })
+          mcpXmlBuffer = ''
+          inMcpXml = false
+        }
+      }
+
+      if (!inMcpXml) {
+        const startIdx = deltaText.indexOf('<mcp__')
+        if (startIdx === -1) {
+          return [{ type: 'text', text: deltaText }]
+        }
+
+        const prefix = deltaText.slice(0, startIdx)
+        if (prefix) {
+          actions.push({ type: 'text', text: prefix })
+        }
+
+        inMcpXml = true
+        appendToBuffer(deltaText.slice(startIdx))
+      } else {
+        appendToBuffer(deltaText)
+      }
+
+      while (inMcpXml && mcpXmlBuffer) {
+        const startIdx = mcpXmlBuffer.indexOf('<mcp__')
+        if (startIdx === -1) {
+          if (mcpXmlBuffer) {
+            actions.push({ type: 'text', text: mcpXmlBuffer })
+          }
+          mcpXmlBuffer = ''
+          inMcpXml = false
+          break
+        }
+
+        if (startIdx > 0) {
+          actions.push({ type: 'text', text: mcpXmlBuffer.slice(0, startIdx) })
+          mcpXmlBuffer = mcpXmlBuffer.slice(startIdx)
+        }
+
+        const tagEnd = mcpXmlBuffer.indexOf('>')
+        if (tagEnd === -1) {
+          inMcpXml = true
+          break
+        }
+
+        const toolName = mcpXmlBuffer.slice(1, tagEnd) // å»æ‰ "<"
+        const endTag = `</${toolName}>`
+        const closeIdx = mcpXmlBuffer.indexOf(endTag, tagEnd + 1)
+        if (closeIdx === -1) {
+          inMcpXml = true
+          break
+        }
+
+        const inputStr = mcpXmlBuffer.slice(tagEnd + 1, closeIdx).trim()
+        let input = null
+        if (inputStr) {
+          try {
+            input = JSON.parse(inputStr)
+          } catch (_) {
+            input = { input: inputStr }
+          }
+        } else {
+          input = {}
+        }
+
+        actions.push({ type: 'tool', name: toolName, args: input })
+
+        const afterClose = closeIdx + endTag.length
+        mcpXmlBuffer = mcpXmlBuffer.slice(afterClose)
+        inMcpXml = mcpXmlBuffer.includes('<mcp__')
+        if (!mcpXmlBuffer) {
+          inMcpXml = false
+          break
+        }
+      }
+
+      return actions
+    }
+
     const flushPendingToolCallById = (id, { force = false } = {}) => {
       const pending = pendingToolCallsById.get(id)
       if (!pending) {
         return
       }
@@ -2961,10 +4052,23 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
       // è‹¥å­˜åœ¨æœªå®Œæˆçš„å·¥å…·è°ƒç”¨ï¼ˆä¾‹å¦‚ args åˆ†æ®µä½†ä¸Šæ¸¸æå‰ç»“æŸï¼‰ï¼Œå°½åŠ› flushï¼Œé¿å…å®¢æˆ·ç«¯å¡æ­»ã€‚
       for (const id of pendingToolCallsById.keys()) {
         flushPendingToolCallById(id, { force: true })
       }
 
+      // MCP XML Bridge å…œåº•ï¼šè‹¥æœ‰æœªé—­åˆæ ‡ç­¾ï¼Œé™çº§ä¸ºåŸæ–‡è¾“å‡ºï¼Œé¿å…å®¢æˆ·ç«¯æ°¸è¿œçœ‹ä¸åˆ°å†…å®¹ã€‚
+      if (mcpXmlBuffer) {
+        const raw = mcpXmlBuffer
+        mcpXmlBuffer = ''
+        inMcpXml = false
+        switchBlockType('text')
+        writeAnthropicSseEvent(res, 'content_block_delta', {
+          type: 'content_block_delta',
+          index: currentIndex,
+          delta: { type: 'text_delta', text: raw }
+        })
+      }
+
       // ğŸ”§ [dadongwo] ä¸ä¾èµ– finishReason åˆ¤æ–­æµç»“æŸ
       // ä¸Šæ¸¸ Antigravity æœåŠ¡å¯èƒ½åœ¨æŸäº›æƒ…å†µä¸‹ï¼ˆå¦‚è¾“å‡ºè¿‡å¤§ã€è¶…æ—¶ï¼‰æå‰ç»“æŸæµï¼Œä½†ä¸å‘é€ finishReasonã€‚
       // åªè¦ HTTP æµæ­£å¸¸ç»“æŸä¸”æœ‰å†…å®¹ï¼Œå°±è§†ä¸ºæ­£å¸¸å®Œæˆã€‚
       if (!finishReason) {
         const hasAnyContent = !!(emittedText || emittedAnyToolUse || emittedThinking)
@@ -3216,10 +4320,17 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
       }
     }
 
     streamResponse.on('data', (chunk) => {
       resetActivityTimeout() // <--- ã€æ–°å¢ã€‘æ”¶åˆ°æ•°æ®äº†ï¼Œé‡ç½®å€’è®¡æ—¶ï¼
+      if (!receivedAnyUpstreamBytes) {
+        receivedAnyUpstreamBytes = true
+        if (firstByteTimeout) {
+          clearTimeout(firstByteTimeout)
+          firstByteTimeout = null
+        }
+      }
 
       if (finished) {
         return
       }
 
@@ -3412,10 +4523,15 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
               delta: { type: 'thinking_delta', thinking: delta }
             })
             // [ç­¾åç¼“å­˜] å½“ thinking å†…å®¹å’Œç­¾åéƒ½æœ‰æ—¶ï¼Œç¼“å­˜ä¾›åç»­è¯·æ±‚ä½¿ç”¨
             if (isAntigravityVendor && sessionHash && emittedThoughtSignature) {
               signatureCache.cacheSignature(sessionHash, fullThought, emittedThoughtSignature)
+              // [æ¨¡å‹å®¶æ—ç¼“å­˜] è®°å½•ç­¾åæ¥æºæ¨¡å‹å®¶æ—ï¼Œç”¨äºè·¨æ¨¡å‹å…¼å®¹æ€§æ£€æŸ¥
+              const modelFamily = extractModelFamily(baseModel)
+              if (modelFamily) {
+                signatureCache.cacheSignatureFamily(emittedThoughtSignature, modelFamily)
+              }
             }
           }
         }
 
         const fullText = extractGeminiText(payload)
@@ -3425,34 +4541,63 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
             delta = fullText.slice(emittedText.length)
           } else {
             delta = fullText
           }
           if (delta) {
-            switchBlockType('text')
+            const actions = processMcpXmlBridgeDelta(delta)
+            for (const action of actions) {
+              if (!action) {
+                continue
+              }
+
+              if (action.type === 'text') {
+                if (!action.text) {
+                  continue
+                }
+                switchBlockType('text')
+                writeAnthropicSseEvent(res, 'content_block_delta', {
+                  type: 'content_block_delta',
+                  index: currentIndex,
+                  delta: { type: 'text_delta', text: action.text }
+                })
+                continue
+              }
+
+              if (action.type === 'tool') {
+                if (currentBlockType === 'text' || currentBlockType === 'thinking') {
+                  stopCurrentBlock()
+                }
+                emitToolUseBlock(action.name, action.args || {}, null)
+              }
+            }
+
             emittedText = fullText
-            writeAnthropicSseEvent(res, 'content_block_delta', {
-              type: 'content_block_delta',
-              index: currentIndex,
-              delta: { type: 'text_delta', text: delta }
-            })
           }
         }
       }
     })
 
     streamResponse.on('end', () => {
       if (activityTimeout) {
         clearTimeout(activityTimeout)
       } // <--- ã€æ–°å¢ã€‘æ­£å¸¸ç»“æŸï¼Œå–æ¶ˆæŠ¥è­¦
+      if (firstByteTimeout) {
+        clearTimeout(firstByteTimeout)
+        firstByteTimeout = null
+      }
 
       finalize().catch((e) => logger.error('Failed to finalize Anthropic SSE response:', e))
     })
 
     streamResponse.on('error', (error) => {
       if (activityTimeout) {
         clearTimeout(activityTimeout)
       } // <--- ã€æ–°å¢ã€‘æŠ¥é”™äº†ï¼Œå–æ¶ˆæŠ¥è­¦
+      if (firstByteTimeout) {
+        clearTimeout(firstByteTimeout)
+        firstByteTimeout = null
+      }
 
       if (finished) {
         return
       }
       const sanitized = sanitizeUpstreamError(error)
@@ -3499,20 +4644,30 @@ async function handleAnthropicMessagesToGemini(req, res, { vendor, baseModel })
       })
     }
 
     // 4. ç¡®ä¿è¿”å› JSON å“åº”ç»™å®¢æˆ·ç«¯ (è®©å®¢æˆ·ç«¯çŸ¥é“å‡ºé”™äº†å¹¶é‡è¯•)
     if (!res.headersSent) {
+      const statusCode = sanitized.statusCode || 502
+      if (statusCode === 429) {
+        const retryAfter =
+          error?.response?.headers?.['retry-after'] ||
+          error?.response?.headers?.['Retry-After'] ||
+          null
+        if (retryAfter) {
+          res.setHeader('Retry-After', String(retryAfter))
+        }
+      }
       // è®°å½•éæµå¼å“åº”æ—¥å¿—
       dumpAnthropicNonStreamResponse(
         req,
-        sanitized.statusCode || 502,
+        statusCode,
         buildAnthropicError(sanitized.upstreamMessage || sanitized.message),
         { vendor, accountId, effectiveModel, forcedVendor: vendor, upstreamError: sanitized }
       )
 
       return res
-        .status(sanitized.statusCode || 502)
+        .status(statusCode)
         .json(buildAnthropicError(sanitized.upstreamMessage || sanitized.message))
     }
 
     // 5. å¦‚æœå¤´å·²ç»å‘äº†ï¼Œèµ° SSE å‘é€é”™è¯¯
     writeAnthropicSseEvent(
@@ -3597,11 +4752,12 @@ async function handleAnthropicCountTokensToGemini(req, res, { vendor }) {
     normalizedMessages || [],
     toolUseIdToName,
     {
       vendor,
       stripThinking: vendor === 'antigravity' && !canEnableThinking,
-      sessionId: sessionHash
+      sessionId: sessionHash,
+      targetModel: model // ç”¨äºç­¾åå…¼å®¹æ€§æ£€æŸ¥
     }
   )
 
   try {
     const countResult =
