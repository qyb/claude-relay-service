diff --git a/src/services/antigravityClient.js b/src/services/antigravityClient.js
index 5ff91638..fa5d6b70 100644
--- a/src/services/antigravityClient.js
+++ b/src/services/antigravityClient.js
@@ -9,124 +9,278 @@ const {
   normalizeAntigravityModelInput,
   getAntigravityModelMetadata
 } = require('../utils/antigravityModel')
 const { cleanJsonSchemaForGemini } = require('../utils/geminiSchemaCleaner')
 const { dumpAntigravityUpstreamRequest } = require('../utils/antigravityUpstreamDump')
+const { dumpAntigravityUpstreamResponse } = require('../utils/antigravityUpstreamResponseDump')
+const {
+  parseGoogleErrorReason,
+  parseGoogleErrorDetailModel,
+  parseGoogleRetryDelayMs
+} = require('../utils/googleErrorParser')
 
 const keepAliveAgent = new https.Agent({
   keepAlive: true,
   keepAliveMsecs: 30000,
   timeout: 120000,
   maxSockets: 100,
   maxFreeSockets: 10
 })
 
 const ANTIGRAVITY_REQUEST_TYPE = 'agent'
+const DEFAULT_MODEL_UNAVAILABLE_COOLDOWN_MS = 60 * 1000
+const MODEL_UNAVAILABLE_COOLDOWN_ENV = 'ANTIGRAVITY_MODEL_UNAVAILABLE_COOLDOWN_MS'
+const DEFAULT_MODEL_CAPACITY_COOLDOWN_MS = 15 * 1000
+const MODEL_CAPACITY_COOLDOWN_ENV = 'ANTIGRAVITY_MODEL_CAPACITY_COOLDOWN_MS'
+const DEFAULT_MAX_FALLBACKS_PER_REQUEST = 1
+const MAX_FALLBACKS_PER_REQUEST_ENV = 'ANTIGRAVITY_MAX_FALLBACKS_PER_REQUEST'
+const MAX_UPSTREAM_ERROR_BODY_BYTES = 64 * 1024
+
+// é’ˆå¯¹ Antigravity ä¸Šæ¸¸ 429 çš„æ¨¡å‹çº§å†·å´ï¼Œé¿å…çŸ­æ—¶é—´å†…æ‰“ç©¿è´¦å·æ± /ç«¯ç‚¹ã€‚
+// ä»…ç”¨äº Antigravity ä¸Šæ¸¸ï¼Œä¸å½±å“ Gemini ç›´è¿ç­‰å…¶å®ƒé“¾è·¯ã€‚
+const modelUnavailableCooldowns = new Map()
+
+function readEnvPositiveInt(name, fallback) {
+  const raw = process.env[name]
+  if (raw === undefined || raw === null || raw === '') {
+    return fallback
+  }
+  const parsed = parseInt(String(raw), 10)
+  if (!Number.isFinite(parsed) || Number.isNaN(parsed) || parsed <= 0) {
+    return fallback
+  }
+  return parsed
+}
 
-// å¯¹é½ è°·æ­Œ è¿‘æœŸå˜æ›´ï¼šAntigravity ä¼šæ ¡éªŒ systemInstruction ç»“æ„ã€‚
-// é‡‡ç”¨æœ€çŸ­å‰ç½®æç¤ºè¯ å¹¶ä¸”åªåšå‰ç½®æ’å…¥ï¼Œä¸è¦†ç›–ç”¨æˆ·åŸæœ‰ system partsã€‚
-const ANTIGRAVITY_MIN_SYSTEM_PROMPT =
-  'You are Antigravity, a powerful agentic AI coding assistant designed by the Google Deepmind team working on Advanced Agentic Coding.You are pair programming with a USER to solve their coding task. The task may require creating a new codebase, modifying or debugging an existing codebase, or simply answering a question.**Proactiveness**'
-const ANTIGRAVITY_MIN_SYSTEM_PROMPT_MARKER =
-  'You are Antigravity, a powerful agentic AI coding assistant designed by the Google Deepmind team working on Advanced Agentic Coding.'
+function readEnvNonNegativeInt(name, fallback) {
+  const raw = process.env[name]
+  if (raw === undefined || raw === null || raw === '') {
+    return fallback
+  }
+  const parsed = parseInt(String(raw), 10)
+  if (!Number.isFinite(parsed) || Number.isNaN(parsed) || parsed < 0) {
+    return fallback
+  }
+  return parsed
+}
 
-/**
- * ä» Google API 429 é”™è¯¯å“åº”ä¸­è§£æ retry-after å»¶è¿Ÿã€‚
- * [dadongwo] è§£æ retry delay å®ç°ã€‚
- * ç­–ç•¥:
- *   1. error.details[] ä¸­æ‰¾ RetryInfo.retryDelay (å¦‚ "0.847655010s")
- *   2. error.details[] ä¸­æ‰¾ ErrorInfo.metadata.quotaResetDelay (å¦‚ "373.801628ms")
- *   3. æ­£åˆ™åŒ¹é… error.message ä¸­çš„ "after Xs"
- * @param {object|string|Buffer} errorBody é”™è¯¯å“åº”ä½“
- * @returns {number|null} å»¶è¿Ÿæ¯«ç§’æ•°ï¼Œè§£æå¤±è´¥è¿”å› null
- */
-function parseRetryDelay(errorBody) {
-  let parsed = null
-  // å®‰å…¨è§£æ JSON
-  if (typeof errorBody === 'string') {
-    try {
-      parsed = JSON.parse(errorBody)
-    } catch (_) {
-      parsed = null
-    }
-  } else if (Buffer.isBuffer(errorBody)) {
-    try {
-      parsed = JSON.parse(errorBody.toString('utf8'))
-    } catch (_) {
-      parsed = null
-    }
-  } else if (errorBody && typeof errorBody === 'object') {
-    parsed = errorBody
+function getModelUnavailableCooldownMs() {
+  return readEnvPositiveInt(MODEL_UNAVAILABLE_COOLDOWN_ENV, DEFAULT_MODEL_UNAVAILABLE_COOLDOWN_MS)
+}
+
+function getModelCapacityCooldownMs() {
+  return readEnvPositiveInt(MODEL_CAPACITY_COOLDOWN_ENV, DEFAULT_MODEL_CAPACITY_COOLDOWN_MS)
+}
+
+function getMaxFallbacksPerRequest() {
+  return readEnvNonNegativeInt(MAX_FALLBACKS_PER_REQUEST_ENV, DEFAULT_MAX_FALLBACKS_PER_REQUEST)
+}
+
+function getModelCooldownInfo(model) {
+  const key = String(model || '').trim()
+  if (!key) {
+    return { remainingMs: 0, reason: '' }
   }
-  if (!parsed || typeof parsed !== 'object') {
+  const entry = modelUnavailableCooldowns.get(key)
+  if (!entry || !entry.untilMs) {
+    return { remainingMs: 0, reason: '' }
+  }
+  const remaining = entry.untilMs - Date.now()
+  if (remaining <= 0) {
+    modelUnavailableCooldowns.delete(key)
+    return { remainingMs: 0, reason: '' }
+  }
+  return { remainingMs: remaining, reason: entry.reason ? String(entry.reason) : '' }
+}
+
+function setModelCooldown(model, cooldownMs, reason) {
+  const key = String(model || '').trim()
+  if (!key) {
+    return
+  }
+  const duration = Number.isFinite(cooldownMs) && cooldownMs > 0 ? Math.trunc(cooldownMs) : 0
+  if (!duration) {
+    return
+  }
+  modelUnavailableCooldowns.set(key, {
+    untilMs: Date.now() + duration,
+    reason: reason ? String(reason) : ''
+  })
+}
+
+function createSyntheticAxiosError({ status, message, data, code, headers } = {}) {
+  const err = new Error(message || 'Antigravity upstream error')
+  err.name = 'AxiosError'
+  err.isAxiosError = true
+  err.code = code
+  err.response = {
+    status: Number.isFinite(status) ? status : 500,
+    data: data || null,
+    headers: headers || {}
+  }
+  return err
+}
+
+function isReadableStream(value) {
+  return (
+    value &&
+    typeof value === 'object' &&
+    typeof value.on === 'function' &&
+    typeof value.pipe === 'function'
+  )
+}
+
+async function readReadableStreamToString(stream, maxBytes = MAX_UPSTREAM_ERROR_BODY_BYTES) {
+  if (!isReadableStream(stream)) {
     return null
   }
-  const details = parsed.error?.details
-  if (Array.isArray(details)) {
-    // ç­–ç•¥1: RetryInfo.retryDelay
-    for (const detail of details) {
-      if (detail?.['@type'] === 'type.googleapis.com/google.rpc.RetryInfo') {
-        const { retryDelay } = detail
-        if (typeof retryDelay === 'string' && retryDelay) {
-          const ms = parseDurationToMs(retryDelay)
-          if (ms !== null) {
-            return ms
-          }
-        }
+
+  return await new Promise((resolve) => {
+    let resolved = false
+    let totalBytes = 0
+    const chunks = []
+
+    const finalize = (text) => {
+      if (resolved) {
+        return
       }
+      resolved = true
+      resolve(text)
     }
-    // ç­–ç•¥2: ErrorInfo.metadata.quotaResetDelay
-    for (const detail of details) {
-      if (detail?.['@type'] === 'type.googleapis.com/google.rpc.ErrorInfo') {
-        const quotaResetDelay = detail.metadata?.quotaResetDelay
-        if (typeof quotaResetDelay === 'string' && quotaResetDelay) {
-          const ms = parseDurationToMs(quotaResetDelay)
-          if (ms !== null) {
-            return ms
+
+    const cleanup = () => {
+      stream.removeListener('data', onData)
+      stream.removeListener('end', onEnd)
+      stream.removeListener('error', onError)
+    }
+
+    const onData = (chunk) => {
+      try {
+        const buf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(String(chunk), 'utf8')
+        const remaining = Math.max(0, maxBytes - totalBytes)
+        if (remaining <= 0) {
+          cleanup()
+          try {
+            stream.destroy()
+          } catch (_) {
+            // ignore
           }
+          finalize(Buffer.concat(chunks).toString('utf8'))
+          return
         }
+
+        if (buf.length > remaining) {
+          chunks.push(buf.subarray(0, remaining))
+          totalBytes += remaining
+          cleanup()
+          try {
+            stream.destroy()
+          } catch (_) {
+            // ignore
+          }
+          finalize(Buffer.concat(chunks).toString('utf8'))
+          return
+        }
+
+        chunks.push(buf)
+        totalBytes += buf.length
+      } catch (_) {
+        cleanup()
+        try {
+          stream.destroy()
+        } catch (err) {
+          // ignore
+        }
+        finalize(Buffer.concat(chunks).toString('utf8'))
       }
     }
+
+    const onEnd = () => {
+      cleanup()
+      finalize(Buffer.concat(chunks).toString('utf8'))
+    }
+
+    const onError = () => {
+      cleanup()
+      finalize(Buffer.concat(chunks).toString('utf8'))
+    }
+
+    stream.on('data', onData)
+    stream.on('end', onEnd)
+    stream.on('error', onError)
+  })
+}
+
+async function normalizeAxiosErrorResponseBody(error) {
+  const data = error?.response?.data
+  if (!data) {
+    return null
   }
-  // ç­–ç•¥3: æ­£åˆ™åŒ¹é… error.message
-  const message = parsed.error?.message
-  if (typeof message === 'string' && message) {
-    const match = message.match(/after\s+(\d+)s\.?/i)
-    if (match && match[1]) {
-      const seconds = parseInt(match[1], 10)
-      if (!Number.isNaN(seconds)) {
-        return seconds * 1000
-      }
+  if (typeof data === 'string') {
+    return data
+  }
+  if (Buffer.isBuffer(data)) {
+    try {
+      const text = data.toString('utf8')
+      error.response.data = text
+      return text
+    } catch (_) {
+      return null
     }
   }
-  return null
-}
-/**
- * è§£æ Go é£æ ¼ duration å­—ç¬¦ä¸²ä¸ºæ¯«ç§’ (å¦‚ "0.847655010s", "373.801628ms")
- */
-function parseDurationToMs(durationStr) {
-  if (!durationStr || typeof durationStr !== 'string') {
+  if (isReadableStream(data)) {
+    const text = await readReadableStreamToString(data)
+    if (typeof text === 'string') {
+      error.response.data = text
+      return text
+    }
     return null
   }
-  const str = durationStr.trim().toLowerCase()
-  // ç§’: "0.847655010s"
-  if (str.endsWith('s') && !str.endsWith('ms')) {
-    const num = parseFloat(str.slice(0, -1))
-    if (!Number.isNaN(num)) {
-      return Math.round(num * 1000)
+  if (typeof data === 'object') {
+    try {
+      const json = JSON.stringify(data)
+      error.response.data = json
+      return json
+    } catch (_) {
+      return null
     }
   }
-  // æ¯«ç§’: "373.801628ms"
-  if (str.endsWith('ms')) {
-    const num = parseFloat(str.slice(0, -2))
-    if (!Number.isNaN(num)) {
-      return Math.round(num)
+  const text = String(data)
+  error.response.data = text
+  return text
+}
+
+function pickUpstreamResponseHeaders(headers) {
+  if (!headers || typeof headers !== 'object') {
+    return null
+  }
+  const get = (key) => {
+    const direct = headers[key]
+    if (direct !== undefined) {
+      return direct
     }
+    const lower = String(key).toLowerCase()
+    return headers[lower]
+  }
+  const picked = {
+    'retry-after': get('retry-after') || null,
+    'x-cloudaicompanion-trace-id': get('x-cloudaicompanion-trace-id') || null,
+    'content-type': get('content-type') || null,
+    'content-length': get('content-length') || null,
+    date: get('date') || null,
+    server: get('server') || null
   }
-  return null
+  return picked
 }
 
+// å¯¹é½ è°·æ­Œ è¿‘æœŸå˜æ›´ï¼šAntigravity ä¼šæ ¡éªŒ systemInstruction ç»“æ„ã€‚
+// é‡‡ç”¨æœ€çŸ­å‰ç½®æç¤ºè¯ å¹¶ä¸”åªåšå‰ç½®æ’å…¥ï¼Œä¸è¦†ç›–ç”¨æˆ·åŸæœ‰ system partsã€‚
+const ANTIGRAVITY_MIN_SYSTEM_PROMPT =
+  'You are Antigravity, a powerful agentic AI coding assistant designed by the Google Deepmind team working on Advanced Agentic Coding.You are pair programming with a USER to solve their coding task. The task may require creating a new codebase, modifying or debugging an existing codebase, or simply answering a question.**Proactiveness**'
+const ANTIGRAVITY_MIN_SYSTEM_PROMPT_MARKER =
+  'You are Antigravity, a powerful agentic AI coding assistant designed by the Google Deepmind team working on Advanced Agentic Coding.'
+
 function getAntigravityApiUrl() {
   return process.env.ANTIGRAVITY_API_URL || 'https://daily-cloudcode-pa.sandbox.googleapis.com'
 }
 
 function normalizeBaseUrl(url) {
@@ -386,12 +540,31 @@ async function request({
     projectId,
     sessionId,
     userPromptId
   })
 
+  const cooldownInfo = getModelCooldownInfo(model)
+  if (cooldownInfo.remainingMs > 0) {
+    const retryAfterSeconds = Math.max(1, Math.ceil(cooldownInfo.remainingMs / 1000))
+    const cooldownReason = String(cooldownInfo.reason || '').trim()
+    const cooldownMessage =
+      cooldownReason === 'MODEL_CAPACITY_EXHAUSTED'
+        ? `Model capacity exhausted (cooldown ${retryAfterSeconds}s)`
+        : `The requested model is currently unavailable (cooldown ${retryAfterSeconds}s)`
+    throw createSyntheticAxiosError({
+      status: 429,
+      code: 'ANTIGRAVITY_MODEL_COOLDOWN',
+      message: cooldownMessage,
+      data: { error: { message: cooldownMessage, reason: cooldownReason || null } },
+      headers: { 'retry-after': String(retryAfterSeconds) }
+    })
+  }
+
   const proxyAgent = ProxyHelper.createProxyAgent(proxyConfig)
   let endpoints = getAntigravityApiUrlCandidates()
+  const maxFallbacksPerRequest = getMaxFallbacksPerRequest()
+  let fallbackCount = 0
 
   // Claude æ¨¡å‹åœ¨ sandbox(daily) ç¯å¢ƒä¸‹å¯¹ tool_use/tool_result çš„å…¼å®¹æ€§ä¸ç¨³å®šï¼Œä¼˜å…ˆèµ° prodã€‚
   // ä¿æŒå¯é…ç½®ä¼˜å…ˆï¼šè‹¥ç”¨æˆ·æ˜¾å¼è®¾ç½®äº† ANTIGRAVITY_API_URLï¼Œåˆ™ä¸æ”¹å˜é¡ºåºã€‚
   if (!process.env.ANTIGRAVITY_API_URL && String(model).includes('claude')) {
     const prodHost = 'cloudcode-pa.googleapis.com'
@@ -551,19 +724,60 @@ async function request({
         const response = await axios(axiosConfig)
         return { model, response }
       } catch (error) {
         lastError = error
         const status = error?.response?.status || null
+        const upstreamHeaders = error?.response?.headers || null
+        const upstreamBodyText = await normalizeAxiosErrorResponseBody(error)
+        const upstreamReason = parseGoogleErrorReason(upstreamBodyText)
+        const upstreamModel = parseGoogleErrorDetailModel(upstreamBodyText)
+        const retryDelayMs = parseGoogleRetryDelayMs(upstreamBodyText)
+
+        dumpAntigravityUpstreamResponse({
+          requestId: envelope.requestId,
+          model,
+          statusCode: status,
+          statusText: error?.response?.statusText || null,
+          responseType: 'error',
+          headers: pickUpstreamResponseHeaders(upstreamHeaders),
+          summary: {
+            baseUrl,
+            url,
+            stream: Boolean(stream),
+            reason: upstreamReason,
+            model: upstreamModel,
+            retryDelayMs: retryDelayMs || null
+          },
+          error: {
+            name: error?.name || null,
+            code: error?.code || null,
+            message: error?.message || null
+          },
+          rawData: typeof upstreamBodyText === 'string' ? upstreamBodyText.slice(0, 4096) : null
+        }).catch(() => {})
 
         const hasNext = index + 1 < endpoints.length
-        if (hasNext && isRetryable(error)) {
+        const isQuotaOrRateLimited =
+          status === 429 &&
+          (upstreamReason === 'QUOTA_EXHAUSTED' || upstreamReason === 'RATE_LIMIT_EXCEEDED')
+        const canFallback =
+          hasNext &&
+          !isQuotaOrRateLimited &&
+          fallbackCount < maxFallbacksPerRequest &&
+          isRetryable(error)
+
+        if (canFallback) {
           logger.warn('âš ï¸ Antigravity upstream error, retrying with fallback baseUrl', {
             status,
             from: baseUrl,
             to: endpoints[index + 1],
-            model
+            model,
+            reason: upstreamReason || undefined,
+            fallbackCount: fallbackCount + 1,
+            maxFallbacksPerRequest
           })
+          fallbackCount += 1
           continue
         }
         throw error
       }
     }
@@ -572,13 +786,12 @@ async function request({
   }
 
   try {
     return await attemptRequest()
   } catch (error) {
-    // å¦‚æœæ˜¯ 429 RESOURCE_EXHAUSTED ä¸”å°šæœªé‡è¯•è¿‡ï¼Œç­‰å¾… 2 ç§’åé‡è¯•ä¸€æ¬¡
     const status = error?.response?.status
-    if (status === 429 && !retriedAfterDelay && !signal?.aborted) {
+    if (status === 429 && !signal?.aborted) {
       const data = error?.response?.data
 
       // å®‰å…¨åœ°å°† data è½¬ä¸ºå­—ç¬¦ä¸²ï¼Œé¿å… stream å¯¹è±¡å¯¼è‡´å¾ªç¯å¼•ç”¨å´©æºƒ
       const safeDataToString = (value) => {
         if (typeof value === 'string') {
@@ -607,49 +820,97 @@ async function request({
         }
         return String(value)
       }
 
       const msg = safeDataToString(data)
+      const msgLower = msg.toLowerCase()
+      const upstreamReason = parseGoogleErrorReason(data) || null
+      const retryDelayMs = parseGoogleRetryDelayMs(data)
+      const traceId =
+        error?.response?.headers?.['x-cloudaicompanion-trace-id'] ||
+        error?.response?.headers?.['X-Cloudaicompanion-Trace-Id'] ||
+        null
+
+      error.antigravity = {
+        ...(error.antigravity && typeof error.antigravity === 'object' ? error.antigravity : {}),
+        reason: upstreamReason,
+        retryDelayMs: retryDelayMs || null,
+        traceId
+      }
 
       // ğŸ” [è¯Šæ–­æ—¥å¿—] è¯¦ç»†è®°å½• 429 é”™è¯¯ä¿¡æ¯
       logger.error(`âŒ [Antigravityè¯Šæ–­] 429 é”™è¯¯è¯¦æƒ…`, {
         model,
         stream,
         errorMessage: msg.substring(0, 500),
+        reason: upstreamReason,
+        retryDelayMs: retryDelayMs || null,
+        traceId,
         responseHeaders: error?.response?.headers,
-        isResourceExhausted: msg.toLowerCase().includes('resource_exhausted'),
-        isNoCapacity: msg.toLowerCase().includes('no capacity'),
+        isResourceExhausted: msgLower.includes('resource_exhausted'),
+        isNoCapacity: msgLower.includes('no capacity'),
+        isModelUnavailable: msgLower.includes('requested model is currently unavailable'),
         url: error?.config?.url,
         tip: 'å¦‚æœæ­¤é”™è¯¯é¢‘ç¹å‘ç”Ÿåœ¨éæµå¼ + å·¥å…·è¯·æ±‚ä¸Šï¼Œå¯èƒ½æ˜¯ API é™åˆ¶'
       })
 
-      if (
-        msg.toLowerCase().includes('resource_exhausted') ||
-        msg.toLowerCase().includes('no capacity')
-      ) {
-        retriedAfterDelay = true
-        logger.warn('â³ Antigravity 429 RESOURCE_EXHAUSTED, waiting 2s before retry', {
-          model,
-          stream
-        })
+      // 429ï¼šæŒ‰ reason åˆ†æµ
+      if (upstreamReason === 'RATE_LIMIT_EXCEEDED' || upstreamReason === 'QUOTA_EXHAUSTED') {
+        // äº¤ç”±ä¸Šå±‚ï¼ˆè´¦å·æ± /è°ƒåº¦å™¨ï¼‰å¤„ç†ï¼šè¿™é‡Œä¸åšå»¶è¿Ÿé‡è¯•ï¼Œé¿å…åŒè´¦å·åå¤æ’é™æµã€‚
+        if (retryDelayMs && retryDelayMs > 0 && error?.response?.headers) {
+          error.response.headers['retry-after'] = String(
+            Math.max(1, Math.ceil(retryDelayMs / 1000))
+          )
+        }
+      } else {
+        const looksLikeCapacityExhausted =
+          upstreamReason === 'MODEL_CAPACITY_EXHAUSTED' ||
+          (!upstreamReason && msgLower.includes('no capacity'))
+
+        if (looksLikeCapacityExhausted) {
+          if (!retriedAfterDelay) {
+            retriedAfterDelay = true
+            const delayMs = retryDelayMs && retryDelayMs > 0 ? retryDelayMs : 2000
+            const boundedDelayMs = Math.min(delayMs, 10000)
+            logger.warn(
+              `â³ Antigravity 429 capacity exhausted, waiting ${boundedDelayMs}ms before retry`,
+              {
+                model,
+                stream,
+                reason: upstreamReason || undefined,
+                parsedDelayMs: retryDelayMs || null
+              }
+            )
+            await new Promise((resolve) => setTimeout(resolve, boundedDelayMs))
+            return await attemptRequest()
+          }
 
-        //  ä»å“åº”ä½“è§£æç²¾ç¡®å»¶è¿Ÿï¼Œå¤±è´¥æ—¶å›é€€ 2000ms
-        let parsedData = data
-        if (typeof data === 'string') {
-          try {
-            parsedData = JSON.parse(data)
-          } catch (_) {
-            parsedData = null
+          // äºŒæ¬¡å¤±è´¥ï¼šè¿›å…¥æ¨¡å‹çº§å†·å´ï¼Œé¿å…çŸ­æ—¶é—´å†…åå¤æ‰“ç©¿ï¼ˆä¸åšæ¨¡å‹é™çº§ï¼‰ã€‚
+          const cooldownMs = Math.max(getModelCapacityCooldownMs(), retryDelayMs || 0)
+          setModelCooldown(model, cooldownMs, 'MODEL_CAPACITY_EXHAUSTED')
+          if (error?.response?.headers) {
+            error.response.headers['retry-after'] = String(
+              Math.max(1, Math.ceil(cooldownMs / 1000))
+            )
           }
+          logger.warn('â³ Antigravity model capacity exhausted, entering model cooldown', {
+            model,
+            cooldownMs
+          })
         }
-        const delayMs = parseRetryDelay(parsedData) || 2000
-        logger.warn(`â³ Antigravity 429 RESOURCE_EXHAUSTED, waiting ${delayMs}ms before retry`, {
+      }
+
+      // æ¨¡å‹ä¸å¯ç”¨ï¼šæŒ‰æ¨¡å‹çº§å†·å´å¤„ç†ï¼Œé¿å…çŸ­æ—¶é—´å†…åå¤è¯·æ±‚ã€‚
+      if (msgLower.includes('requested model is currently unavailable')) {
+        const cooldownMs =
+          (retryDelayMs && retryDelayMs > 0 ? retryDelayMs : null) ||
+          getModelUnavailableCooldownMs()
+        setModelCooldown(model, cooldownMs, 'model_unavailable')
+        logger.warn('â³ Antigravity model unavailable, entering cooldown', {
           model,
-          parsedDelayMs: delayMs
+          cooldownMs
         })
-        await new Promise((resolve) => setTimeout(resolve, delayMs))
-        return await attemptRequest()
       }
     }
     throw error
   }
 }
